
AVRASM ver. 2.2.6  D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\main.asm Mon May 31 10:44:12 2021

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\main.asm(27): Including file 'D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\definitions.asm'
D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\main.asm(28): Including file 'D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\macros.asm'
D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\main.asm(178): Including file 'D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\lcd.asm'
D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\main.asm(179): Including file 'D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\printf.asm'
D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\main.asm(180): Including file 'D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\wire1.asm'
D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\main.asm(181): Including file 'D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\math.asm'
D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\main.asm(182): Including file 'D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\sound.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\main.asm(27): Including file 'D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\definitions.asm'
D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\main.asm(28): Including file 'D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\macros.asm'
D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\main.asm(178): Including file 'D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\lcd.asm'
D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\main.asm(179): Including file 'D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\printf.asm'
D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\main.asm(180): Including file 'D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\wire1.asm'
D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\main.asm(181): Including file 'D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\math.asm'
D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\main.asm(182): Including file 'D:\EPFL\2ème Année\BA4\Microcontrôleur\Thermotor\sound.asm'
                                 
                                  
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;=====================MACROS============================
                                  .macro	MOTOR 
                                 	P0	PORTE,SERVO1	;low
                                 	WAIT_US 20000
                                 	P1	PORTE,SERVO1		
                                 loop:
                                 	SUBI2	@0,@1,0x1
                                 	brne	loop
                                 	P0	PORTE,SERVO1	;high
                                 	.endmacro
                                 
                                 .macro	AFFICHER
                                 	rcall	lcd_home
                                 
                                 	mov a0,@0
                                 	PRINTF	LCD
                                 	.db	"T=",FDEC,a,"C ",CR,0  ;display temperature
                                 
                                 	mov a0, @1
                                 	mov b0, @2
                                 	PRINTF	LCD
                                 	.db	LF,"Tmin=",FDEC,b," Tmax=",FDEC,a,"   ",0  ;display Tmin & Tmax
                                 	.endmacro
                                 
                                 
                                 .include "definitions.asm"
                                 
                                 ; purpose library, definition of addresses and constants
                                 ; 20171114 A.S.
                                 
                                 ; === definitions  ===
                                 .list
                                 .include "macros.asm"
                                 
                                 ; purpose library, general-purpose macros
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 ; v2019.01 20180820 AxS
                                 
                                 ; ==============
                                 ; 	pointers
                                 ; ==============
                                 
                                 ; --- loading an immediate into a pointer XYZ,SP ---
                                 .macro 	LDIX	; sram
                                 	ldi	xl, low(@0)
                                 	ldi	xh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIY	; sram	
                                 	ldi	yl, low(@0)
                                 	ldi	yh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIZ	; sram
                                 	ldi	zl, low(@0)
                                 	ldi	zh,high(@0)
                                 	
                                 	.endmacro
                                 .macro	LDZD	; sram, reg	; sram+reg -> Z
                                 	mov	zl,@1
                                 	clr	zh
                                 	subi	zl, low(-@0)
                                 	sbci	zh,high(-@0)
                                 	.endmacro
                                 .macro	LDSP	; sram
                                 	ldi	r16, low(@0)
                                 	out	spl,r16
                                 	ldi	r16,high(@0)
                                 	out	sph,r16
                                 	.endmacro
                                 
                                 ; --- load/store SRAM addr into pointer XYZ ---	
                                 .macro 	LDSX	; sram
                                 	lds	xl,@0
                                 	lds	xh,@0+1
                                 	.endmacro
                                 .macro 	LDSY	; sram
                                 	lds	yl,@0
                                 	lds	yh,@0+1
                                 	.endmacro
                                 .macro 	LDSZ	; sram
                                 	lds	zl,@0
                                 	lds	zh,@0+1
                                 	.endmacro
                                 .macro 	STSX	; sram
                                 	sts	@0,  xl
                                 	sts	@0+1,xh
                                 	.endmacro	
                                 .macro 	STSY	; sram
                                 	sts	@0,  yl
                                 	sts	@0+1,yh
                                 	.endmacro
                                 .macro 	STSZ	; sram
                                 	sts	@0,  zl
                                 	sts	@0+1,zh
                                 	.endmacro	
                                 
                                 ; --- push/pop pointer XYZ ---
                                 .macro	PUSHX			; push X
                                 	push	xl
                                 	push	xh
                                 	.endmacro
                                 .macro	POPX			; pop X
                                 	pop	xh
                                 	pop	xl
                                 	.endmacro
                                 	
                                 .macro	PUSHY			; push Y
                                 	push	yl
                                 	push	yh
                                 	.endmacro
                                 .macro	POPY			; pop Y
                                 	pop	yh
                                 	pop	yl
                                 	.endmacro
                                 
                                 .macro	PUSHZ			; push Z
                                 	push	zl
                                 	push	zh
                                 	.endmacro
                                 .macro	POPZ			; pop Z
                                 	pop	zh
                                 	pop	zl
                                 	.endmacro
                                 
                                 ; --- multiply/divide Z ---	
                                 .macro	MUL2Z			; multiply Z by 2
                                 	lsl	zl
                                 	rol	zh
                                 	.endmacro
                                 .macro	DIV2Z			; divide Z by 2
                                 	lsr	zh
                                 	ror	zl
                                 	.endmacro
                                 
                                 ; --- add register to pointer XYZ ---	
                                 .macro	ADDX	;reg		; x <- y+reg
                                 	add	xl,@0
                                 	brcc	PC+2
                                 	subi	xh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDY	;reg		; y <- y+reg
                                 	add	yl,@0
                                 	brcc	PC+2
                                 	subi	yh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDZ	;reg		; z <- z+reg
                                 	add	zl,@0
                                 	brcc	PC+2
                                 	subi	zh,-1		; add carry
                                 	.endmacro
                                 
                                 ; ===================
                                 ; 	miscellaneous
                                 ; ===================
                                 
                                 ; --- output/store (regular I/O space) immediate value ---
                                 .macro	OUTI	; port,k	output immediate value to port
                                 	ldi	w,@1
                                 	out	@0,w
                                 	.endmacro
                                 
                                 ; --- output/store (extended I/O space) immediate value ---
                                 .macro OUTEI	; port,k    output immediate value to port
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 ; --- add immediate value ---
                                 .macro	ADDI
                                 	subi	@0,-@1
                                 	.endmacro
                                 .macro	ADCI
                                 	sbci	@0,-@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with range limitation ---
                                 .macro	INC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	brlo	PC+3
                                 	ldi	@0,@1	
                                 	rjmp	PC+2
                                 	inc	@0
                                 	.endmacro
                                 
                                 .macro	DEC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@0
                                 	rjmp	PC+2
                                 	ldi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with cyclic range ---
                                 .macro	INC_CYC	; reg,low,high
                                 	cpi	@0,@2
                                 	brsh	_low	; reg>=high then reg=low
                                 	cpi	@0,@1
                                 	brlo	_low	; reg< low  then reg=low
                                 	inc	@0
                                 	rjmp	_done
                                 _low:	ldi	@0,@1
                                 _done:	
                                     .endmacro
                                 	
                                 .macro	DEC_CYC	; reg,low,high
                                 	cpi	@0,@1
                                 	breq	_high	; reg=low then reg=high
                                 	brlo	_high	; reg<low then reg=high
                                 	dec	@0	
                                 	cpi	@0,@2
                                 	brsh	_high	; reg>=high then high
                                 	rjmp	_done
                                 _high:	ldi	@0,@2
                                 _done:	
                                 	.endmacro
                                 
                                 .macro	INCDEC	;port,b1,b2,reg,low,high
                                 	sbic	@0,@1
                                 	rjmp	PC+6
                                 
                                 	cpi	@3,@5
                                 	brlo	PC+3
                                 	ldi	@3,@4	
                                 	rjmp	PC+2
                                 	inc	@3
                                 
                                 	sbic	@0,@2
                                 	rjmp	PC+7
                                 	
                                 	cpi	@3,@4
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@3
                                 	rjmp	PC+2
                                 	ldi	@3,@5
                                 	.endmacro		
                                 
                                 ; --- wait loops ---
                                 ; wait 10...196608 cycles
                                 .macro	WAIT_C	; k
                                 	ldi	w,  low((@0-7)/3)
                                 	mov	u,w			; u=LSB
                                 	ldi	w,high((@0-7)/3)+1	; w=MSB
                                 	dec	u
                                 	brne	PC-1
                                 	dec	u
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait micro-seconds (us)
                                 ; us = x*3*1000'000/clock)	==> x=us*clock/3000'000
                                 .macro	WAIT_US ; k
                                 	ldi	w, low((clock/1000*@0/3000)-1)
                                 	mov	u,w
                                 	ldi	w,high((clock/1000*@0/3000)-1)+1 ; set up: 3 cyles
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait mili-seconds (ms)
                                 .macro	WAIT_MS ; k
                                 	ldi	w, low(@0)
                                 	mov	u,w		; u = LSB	
                                 	ldi	w,high(@0)+1	; w = MSB
                                 wait_ms:
                                 	push	w		; wait 1000 usec
                                 	push	u
                                 	ldi	w, low((clock/3000)-5)	
                                 	mov	u,w
                                 	ldi	w,high((clock/3000)-5)+1
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	pop	u
                                 	pop	w
                                 	
                                 	dec	u
                                 	brne	wait_ms
                                 	dec	w
                                 	brne	wait_ms
                                 	.endmacro
                                 
                                 ; --- conditional jumps/calls ---
                                 .macro	JC0			; jump if carry=0
                                 	brcs	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JC1			; jump if carry=1
                                 	brcc	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 .macro	JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	breq	@2
                                 	.endmacro
                                 .macro	_JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rjmp	@2
                                 	.endmacro	
                                 .macro	JNK	; reg,k,addr	; jump if not(reg=k)
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro 
                                 
                                 .macro	CK	; reg,k,addr	; call if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CNK	; reg,k,addr	; call if not(reg=k)
                                 	cpi	@0,@1
                                 	breq	PC+2
                                 	rcall	@2
                                 	.endmacro 
                                 
                                 .macro	JSK	; sram,k,addr	; jump if sram=k
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	breq	@2
                                 	.endmacro 
                                 .macro	JSNK	; sram,k,addr	; jump if not(sram=k)
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- loops ---
                                 .macro	DJNZ	; reg,addr	; decr and jump if not zero
                                 	dec	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	DJNK	; reg,k,addr	; decr and jump if not k
                                 	dec	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	IJNZ	; reg,addr	; inc and jump if not zero
                                 	inc	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	breq	PC+2	
                                 	rjmp	@2
                                 	.endmacro
                                 
                                 .macro	DSJNK	; sram,k,addr	; dec sram and jump if not k
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- table lookup ---
                                 .macro	LOOKUP	;reg, index,tbl
                                 	push	ZL
                                 	push	ZH
                                 	mov	zl,@1		; move index into z
                                 	clr	zh
                                 	subi	zl, low(-2*@2)	; add base address of table
                                 	sbci	zh,high(-2*@2)	
                                 	lpm			; load program memory (into r0)
                                 	mov	@0,r0
                                 	pop	ZH
                                 	pop	ZL
                                 	.endmacro
                                 
                                 .macro	LOOKUP2	;r1,r0, index,tbl
                                 	mov	zl,@2		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	subi	zl, low(-2*@3)	; add base address of table
                                 	sbci	zh,high(-2*@3)
                                 	lpm			; get LSB byte
                                 	mov	w,r0		; temporary store LSB in w
                                 	adiw	zl,1		; increment Z
                                 	lpm			; get MSB byte
                                 	mov	@0,r0		; mov MSB to res1
                                 	mov	@1,w		; mov LSB to res0
                                 	.endmacro
                                 
                                 .macro	LOOKUP4	;r3,r2,r1,r0, index,tbl
                                 	mov	zl,@4		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh	
                                 	subi	zl, low(-2*@5)	; add base address of table
                                 	sbci	zh,high(-2*@5)
                                 	lpm
                                 	mov	@1,r0		; load high word LSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0		; load high word MSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@3,r0		; load low word LSB		
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0		; load low word MSB
                                 	.endmacro
                                 
                                 .macro	LOOKDOWN ;reg,index,tbl
                                 	ldi	ZL, low(2*@2)	; load table address
                                 	ldi	ZH,high(2*@2)
                                 	clr	@1
                                 loop:	lpm
                                 	cp	r0,@0
                                 	breq	found
                                 	inc	@1
                                 	adiw	ZL,1
                                 	tst	r0
                                 	breq	notfound
                                 	rjmp	loop
                                 notfound:
                                 	ldi	@1,-1
                                 found:	
                                 	.endmacro
                                 
                                 ; --- branch table ---
                                 .macro	C_TBL	; reg,tbl
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl
                                 	icall
                                 	.endmacro
                                 .macro	J_TBL	; reg,tbl	
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl	
                                 	ijmp
                                 	.endmacro
                                 
                                 .macro	BRANCH	; reg		; branching using the stack
                                 	ldi	w, low(tbl)
                                 	add	w,@0
                                 	push	w
                                 	ldi	w,high(tbl)
                                 	brcc	PC+2
                                 	inc	w
                                 	push	w
                                 	ret
                                 tbl:
                                 	.endmacro	
                                 
                                 ; --- multiply/division ---
                                 .macro	DIV2	; reg
                                 	lsr	@0
                                 	.endmacro
                                 .macro	DIV4	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro	
                                 .macro	DIV8	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro
                                 	
                                 .macro	MUL2	; reg
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL4	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL8	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 
                                 ; ====================================
                                 ; 	extending existing instructios
                                 ; ====================================
                                 
                                 ; --- immediate ops with r0..r15 ---
                                 .macro	_ADDI
                                 	ldi	w,@1
                                 	add	@0,w
                                 	.endmacro
                                 .macro	_ADCI
                                 	ldi	w,@1
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	_SUBI
                                 	ldi	w,@1
                                 	sub	@0,w
                                 	.endmacro
                                 .macro	_SBCI
                                 	ldi	w,@1
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	_ANDI
                                 	ldi	w,@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_ORI
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_EORI
                                 	ldi	w,@1
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	_SBR
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_CBR
                                 	ldi	w,~@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_CPI
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	.endmacro
                                 .macro	_LDI
                                 	ldi	w,@1
                                 	mov	@0,w
                                 	.endmacro
                                 
                                 ; --- bit access for port p32..p63 ---
                                 .macro	_SBI
                                 	in	w,@0
                                 	ori	w,1<<@1
                                 	out	@0,w
                                 	.endmacro
                                 .macro	_CBI
                                 	in	w,@0
                                 	andi	w,~(1<<@1)
                                 	out	@0,w
                                 	.endmacro
                                 	
                                 ; --- extending branch distance to +/-2k ---
                                 .macro	_BREQ
                                 	brne	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRNE
                                 	breq	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCS
                                 	brcc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCC
                                 	brcs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRSH
                                 	brlo	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLO
                                 	brsh	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRMI
                                 	brpl	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRPL
                                 	brmi	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRGE
                                 	brlt	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLT
                                 	brge	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHS
                                 	brhc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHC
                                 	brhs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTS
                                 	brtc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTC
                                 	brts	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVS
                                 	brvc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVC
                                 	brvs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRIE
                                 	brid	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRID
                                 	brie	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 ; ====================
                                 ; 	bit operations
                                 ; ====================
                                 
                                 ; --- moving bits ---
                                 .macro	MOVB	; reg1,b1, reg2,b2	; reg1,bit1 <- reg2,bit2
                                 	bst	@2,@3
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	OUTB	; port1,b1, reg2,b2	; port1,bit1 <- reg2,bit2
                                 	sbrs	@2,@3
                                 	cbi	@0,@1
                                 	sbrc	@2,@3
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INB	; reg1,b1, port2,b2	; reg1,bit1 <- port2,bit2
                                 	sbis	@2,@3
                                 	cbr	@0,1<<@1
                                 	sbic	@2,@3
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 
                                 .macro	Z2C				; zero to carry
                                 	sec
                                 	breq	PC+2	; (Z=1)
                                 	clc
                                 	.endmacro
                                 .macro	Z2INVC				; zero to inverse carry
                                 	sec
                                 	brne	PC+2	; (Z=0)
                                 	clc
                                 	.endmacro
                                 
                                 .macro	C2Z				; carry to zero
                                 	sez
                                 	brcs	PC+2	; (C=1)
                                 	clz
                                 	.endmacro
                                 
                                 .macro	B2C	; reg,b			; bit to carry
                                 	sbrc	@0,@1
                                 	sec
                                 	sbrs	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2B	; reg,b			; carry to bit
                                 	brcc	PC+2
                                 	sbr	@0,(1<<@1)
                                 	brcs	PC+2
                                 	cbr	@0,(1<<@1)
                                 	.endmacro
                                 .macro	P2C	; port,b		; port to carry
                                 	sbic	@0,@1
                                 	sec
                                 	sbis	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2P	; port,b		; carry to port
                                 	brcc	PC+2
                                 	sbi	@0,@1
                                 	brcs	PC+2
                                 	cbi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inverting bits ---
                                 .macro	INVB	; reg,bit		; inverse reg,bit
                                 	ldi	w,(1<<@1)
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	INVP	; port,bit		; inverse port,bit	
                                 	sbis	@0,@1
                                 	rjmp	PC+3
                                 	cbi	@0,@1
                                 	rjmp	PC+2
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INVC				; inverse carry	
                                 	brcs	PC+3
                                 	sec
                                 	rjmp	PC+2
                                 	clc
                                 	.endmacro
                                 
                                 ; --- setting a single bit ---
                                 .macro	SETBIT	; reg(0..7)
                                 ; in	reg (0..7)
                                 ; out	reg with bit (0..7) set to 1.
                                 ; 0=00000001
                                 ; 1=00000010
                                 ; ...
                                 ; 7=10000000
                                 	mov	w,@0
                                 	clr	@0
                                 	inc	@0
                                 	andi	w,0b111	
                                 	breq	PC+4
                                 	lsl	@0
                                 	dec	w
                                 	brne	PC-2
                                 	.endmacro
                                 
                                 ; --- logical operations with masks ---
                                 .macro	MOVMSK	; reg1,reg2,mask	; reg1 <- reg2 (mask)
                                 	ldi	w,~@2	
                                 	and	@0,w
                                 	ldi	w,@2
                                 	and	@1,w	
                                 	or	@0,@1
                                 	.endmacro	
                                 .macro	ANDMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	ori	w,~@2
                                 	and	@0,w
                                 	.endmacro	
                                 .macro	ORMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	andi	w,@2
                                 	or	@0,w
                                 	.endmacro
                                 	
                                 ; --- logical operations on bits ---
                                 .macro	ANDB	; r1,b1, r2,b2, r3,b3	; reg1,b1 <- reg2,b2 AND reg3,b3
                                 	set
                                 	sbrs	@4,@5	
                                 	clt
                                 	sbrs	@2,@3	
                                 	clt
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	ORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 OR reg3.b3
                                 	clt
                                 	sbrc	@4,@5	
                                 	set
                                 	sbrc	@2,@3	
                                 	set
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	EORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 XOR reg3.b3
                                 	sbrc	@4,@5
                                 	rjmp	f1
                                 f0:	bst	@2,@3	
                                 	rjmp	PC+4
                                 f1:	set
                                 	sbrc	@0,@1
                                 	clt
                                 	bld	@0,@0	
                                 	.endmacro
                                 	
                                 ; --- operations based on register bits ---
                                 .macro	FB0	; reg,bit		; bit=0
                                 	cbr	@0,1<<@1
                                 	.endmacro
                                 .macro	FB1	; reg,bit		; bit=1
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 .macro	_FB0	; reg,bit		; bit=0
                                 	ldi	w,~(1<<@1)
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_FB1	; reg,bit		; bit=1
                                 	ldi	w,1<<@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	SB0	; reg,bit,addr		; skip if bit=0
                                 	sbrc	@0,@1
                                 	.endmacro
                                 .macro	SB1	; reg,bit,addr		; skip if bit=1
                                 	sbrs	@0,@1
                                 	.endmacro
                                 .macro	JB0	; reg,bit,addr		; jump if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JB1	; reg,bit,addr		; jump if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CB0	; reg,bit,addr		; call if bit=0
                                 	sbrs	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CB1	; reg,bit,addr		; call if bit=1
                                 	sbrc	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WB0	; reg,bit		; wait if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WB1	; reg,bit		; wait if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RB0	; reg,bit		; return if bit=0
                                 	sbrs	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RB1	; reg,bit		; return if bit=1
                                 	sbrc	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if bit=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WB0T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrs	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if bit=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WB1T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrc	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 	
                                 ; --- operations based on port bits ---
                                 .macro	P0	; port,bit		; port=0
                                 	cbi	@0,@1
                                 	.endmacro
                                 .macro	P1	; port,bit		; port=1
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	SP0	; port,bit		; skip if port=0
                                 	sbic	@0,@1
                                 	.endmacro
                                 .macro	SP1	; port,bit		; skip if port=1
                                 	sbis	@0,@1
                                 	.endmacro
                                 .macro	JP0	; port,bit,addr		; jump if port=0
                                 	sbis	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JP1	; port,bit,addr		; jump if port=1
                                 	sbic	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CP0	; port,bit,addr		; call if port=0
                                 	sbis	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CP1	; port,bit,addr		; call if port=1
                                 	sbic	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WP0	; port,bit		; wait if port=0
                                 	sbis	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WP1	; port,bit		; wait if port=1
                                 	sbic	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RP0	; port,bit		; return if port=0
                                 	sbis	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RP1	; port,bit		; return if port=1
                                 	sbic	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if port=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WP0T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbis	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if port=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WP1T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbic	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 
                                 ; ===========================
                                 ; 	multi-byte operations
                                 ; ===========================
                                 
                                 .macro	SWAP4			; swap 2 variables
                                 	mov	w ,@0
                                 	mov	@0,@4
                                 	mov	@4,w
                                 	mov	w ,@1
                                 	mov	@1,@5
                                 	mov	@5,w
                                 	mov	w ,@2
                                 	mov	@2,@6
                                 	mov	@6,w
                                 	mov	w ,@3
                                 	mov	@3,@7
                                 	mov	@7,w
                                 	.endmacro
                                 .macro	SWAP3
                                 	mov	w ,@0
                                 	mov	@0,@3
                                 	mov	@3,w
                                 	mov	w ,@1
                                 	mov	@1,@4
                                 	mov	@4,w
                                 	mov	w ,@2
                                 	mov	@2,@5
                                 	mov	@5,w
                                 	.endmacro
                                 .macro	SWAP2
                                 	mov	w ,@0
                                 	mov	@0,@2
                                 	mov	@2,w
                                 	mov	w ,@1
                                 	mov	@1,@3
                                 	mov	@3,w
                                 	.endmacro
                                 .macro	SWAP1
                                 	mov	w ,@0
                                 	mov	@0,@1
                                 	mov	@1,w
                                 	.endmacro
                                 
                                 .macro	LDX4	;r..r0		; load from (x+)
                                 	ld	@3,x+
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX3	;r..r0
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX2	;r..r0	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 	
                                 .macro	LDY4	;r..r0		; load from (y+)
                                 	ld	@3,y+
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY3	;r..r0
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY2	;r..r0	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 
                                 .macro	LDZ4	;r..r0		; load from (z+)
                                 	ld	@3,z+
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ3	;r..r0
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ2	;r..r0
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 
                                 .macro	STX4	;r..r0		; store to (x+)
                                 	st	x+,@3
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX3	;r..r0
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX2	;r..r0
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 	
                                 .macro	STY4	;r..r0		; store to (y+)
                                 	st	y+,@3
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY3	;r..r0
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY2	;r..r0	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 	
                                 .macro	STZ4	;r..r0		; store to (z+)
                                 	st	z+,@3
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ3	;r..r0
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ2	;r..r0	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 	
                                 .macro	STI4	;addr,k		; store immediate
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	ldi	w,byte4(@1)
                                 	sts	@0+3,w	
                                 	.endmacro	
                                 .macro	STI3	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	.endmacro	
                                 .macro	STI2	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	STI	;addr,k
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	INC4			; increment
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC3
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC2
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 
                                 .macro	DEC4			; decrement
                                 	ldi	w,0xff
                                 	add	@3,w
                                 	adc	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC3
                                 	ldi	w,0xff
                                 	add	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC2
                                 	ldi	w,0xff
                                 	add	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 
                                 .macro	CLR9			; clear (also clears the carry)
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	clr	@8
                                 	.endmacro
                                 .macro	CLR8
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	.endmacro
                                 .macro	CLR7
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	.endmacro
                                 .macro	CLR6
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	.endmacro
                                 .macro	CLR5
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	.endmacro
                                 .macro	CLR4
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	.endmacro
                                 .macro	CLR3
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	.endmacro
                                 .macro	CLR2
                                 	sub	@0,@0
                                 	clr	@1
                                 	.endmacro
                                 
                                 .macro	COM4			; one's complement
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	.endmacro
                                 .macro	COM3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	.endmacro
                                 .macro	COM2
                                 	com	@0
                                 	com	@1
                                 	.endmacro
                                 
                                 .macro	NEG4			; negation (two's complement)
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG2
                                 	com	@0
                                 	com	@1
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 	
                                 .macro	LDI4 	; r..r0, k	; load immediate
                                 	ldi	@3,  low(@4)
                                 	ldi	@2, high(@4)
                                 	ldi	@1,byte3(@4)
                                 	ldi	@0,byte4(@4)
                                 	.endmacro
                                 .macro	LDI3
                                 	ldi	@2,  low(@3)
                                 	ldi	@1, high(@3)
                                 	ldi	@0,byte3(@3)
                                 	.endmacro
                                 .macro	LDI2
                                 	ldi	@1,  low(@2)
                                 	ldi	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LDS4			; load direct from SRAM
                                 	lds	@3,@4
                                 	lds	@2,@4+1
                                 	lds	@1,@4+2
                                 	lds	@0,@4+3
                                 	.endmacro
                                 .macro	LDS3
                                 	lds	@2,@3
                                 	lds	@1,@3+1
                                 	lds	@0,@3+2
                                 	.endmacro
                                 .macro	LDS2
                                 	lds	@1,@2
                                 	lds	@0,@2+1
                                 	.endmacro
                                 
                                 .macro	STS4			; store direct to SRAM
                                 	sts	@0+0,@4
                                 	sts	@0+1,@3
                                 	sts	@0+2,@2
                                 	sts	@0+3,@1
                                 	.endmacro
                                 .macro	STS3
                                 	sts	@0+0,@3
                                 	sts	@0+1,@2
                                 	sts	@0+2,@1
                                 	.endmacro
                                 .macro	STS2
                                 	sts	@0+0,@2
                                 	sts	@0+1,@1
                                 	.endmacro
                                 
                                 .macro	STDZ4	; d, r3,r2,r1,r0
                                 	std	z+@0+0,@4
                                 	std	z+@0+1,@3
                                 	std	z+@0+2,@2
                                 	std	z+@0+3,@1
                                 	.endmacro
                                 .macro	STDZ3	; d, r2,r1,r0
                                 	std	z+@0+0,@3
                                 	std	z+@0+1,@2
                                 	std	z+@0+2,@1
                                 	.endmacro
                                 .macro	STDZ2	; d, r1,r0
                                 	std	z+@0+0,@2
                                 	std	z+@0+1,@1
                                 	.endmacro
                                 	
                                 .macro	LPM4			; load program memory
                                 	lpm
                                 	mov	@3,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM3
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM2
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 
                                 .macro	MOV4			; move between registers
                                 	mov	@3,@7
                                 	mov	@2,@6
                                 	mov	@1,@5
                                 	mov	@0,@4
                                 	.endmacro
                                 .macro	MOV3
                                 	mov	@2,@5
                                 	mov	@1,@4
                                 	mov	@0,@3
                                 	.endmacro
                                 .macro	MOV2
                                 	mov	@1,@3
                                 	mov	@0,@2
                                 	.endmacro
                                 
                                 .macro	ADD4			; add
                                 	add	@3,@7
                                 	adc	@2,@6
                                 	adc	@1,@5
                                 	adc	@0,@4
                                 	.endmacro
                                 .macro	ADD3
                                 	add	@2,@5
                                 	adc	@1,@4
                                 	adc	@0,@3
                                 	.endmacro
                                 .macro	ADD2
                                 	add	@1,@3
                                 	adc	@0,@2
                                 	.endmacro
                                 
                                 .macro	SUB4			; subtract
                                 	sub	@3,@7
                                 	sbc	@2,@6
                                 	sbc	@1,@5
                                 	sbc	@0,@4
                                 	.endmacro
                                 .macro	SUB3
                                 	sub	@2,@5
                                 	sbc	@1,@4
                                 	sbc	@0,@3
                                 	.endmacro
                                 .macro	SUB2
                                 	sub	@1,@3
                                 	sbc	@0,@2
                                 	.endmacro
                                 	
                                 .macro	CP4			; compare
                                 	cp	@3,@7
                                 	cpc	@2,@6
                                 	cpc	@1,@5
                                 	cpc	@0,@4
                                 	.endmacro
                                 .macro	CP3
                                 	cp	@2,@5
                                 	cpc	@1,@4
                                 	cpc	@0,@3
                                 	.endmacro
                                 .macro	CP2
                                 	cp	@1,@3
                                 	cpc	@0,@2
                                 	.endmacro
                                 
                                 .macro	TST4			; test
                                 	clr	w
                                 	cp	@3,w
                                 	cpc	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST3
                                 	clr	w
                                 	cp	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST2
                                 	clr	w
                                 	cp	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 
                                 .macro	ADDI4			; add immediate
                                 	subi	@3,  low(-@4)
                                 	sbci	@2, high(-@4)
                                 	sbci	@1,byte3(-@4)
                                 	sbci	@0,byte4(-@4)
                                 	.endmacro
                                 .macro	ADDI3
                                 	subi	@2,  low(-@3)
                                 	sbci	@1, high(-@3)
                                 	sbci	@0,byte3(-@3)
                                 	.endmacro
                                 .macro	ADDI2
                                 	subi	@1,  low(-@2)
                                 	sbci	@0, high(-@2)
                                 	.endmacro
                                 	
                                 .macro	SUBI4			; subtract immediate
                                 	subi	@3,  low(@4)
                                 	sbci	@2, high(@4)
                                 	sbci	@1,byte3(@4)
                                 	sbci	@0,byte4(@4)
                                 	.endmacro
                                 .macro	SUBI3
                                 	subi	@2,  low(@3)
                                 	sbci	@1, high(@3)
                                 	sbci	@0,byte3(@3)
                                 	.endmacro
                                 .macro	SUBI2
                                 	subi	@1,  low(@2)
                                 	sbci	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LSL5			; logical shift left
                                 	lsl	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL4
                                 	lsl	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL3
                                 	lsl	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL2
                                 	lsl	@1
                                 	rol	@0
                                 	.endmacro
                                 	
                                 .macro	LSR4			; logical shift right
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	LSR3
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	LSR2
                                 	lsr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ASR4			; arithmetic shift right
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ASR3
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ASR2
                                 	asr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ROL8			; rotate left through carry
                                 	rol	@7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 
                                 .macro	ROR8			; rotate right through carry
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	ror	@7
                                 	.endmacro
                                 .macro	ROR7
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	.endmacro
                                 .macro	ROR6
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	.endmacro
                                 .macro	ROR5
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	.endmacro	
                                 .macro	ROR4
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ROR3
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ROR2
                                 	ror	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	PUSH2
                                 	push	@0
                                 	push	@1
                                 	.endmacro	
                                 .macro	POP2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 
                                 .macro	PUSH3
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	.endmacro	
                                 .macro	POP3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 	
                                 .macro	PUSH4
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	.endmacro	
                                 .macro	POP4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 	
                                 .macro	PUSH5
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	push	@4
                                 	.endmacro	
                                 .macro	POP5
                                 	pop	@4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 
                                 ; --- SRAM operations ---
                                 .macro	INCS4	; sram		; increment SRAM 4-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 	brne	end
                                 	lds	w,@0+3
                                 	inc	w
                                 	sts	@0+3,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS3	; sram		; increment SRAM 3-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS2	; sram		; increment SRAM 2-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS	; sram		; increment SRAM 1-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	DECS4	; sram		; decrement SRAM 4-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	lds	u,@0+3
                                 	sbc	u,w
                                 	sts	@0+3,u
                                 	.endmacro
                                 .macro	DECS3	; sram		; decrement SRAM 3-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	.endmacro
                                 .macro	DECS2	; sram		; decrement SRAM 2-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	.endmacro
                                 .macro	DECS	; sram		; decrement
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	MOVS4	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	lds	w,@3+1
                                 	sts	@0+3,w	
                                 	.endmacro
                                 .macro	MOVS3	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	.endmacro
                                 .macro	MOVS2	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	MOVS	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	SEXT	; reg1,reg0	; sign extend
                                 	clr	@0
                                 	sbrc	@1,7
                                 	dec	@0
                                 	.endmacro
                                 
                                 ; =======================================
                                 ;	Jump/Call with constant arguments
                                 ; =======================================
                                 	
                                 ; --- calls with arguments a,b,XYZ ---
                                 .macro	CX	; subroutine,x
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CXY	; subroutine,x,y
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXZ	; subroutine,x,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	zl, low(@2)
                                 	ldi	zh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXYZ	; subroutine,x,y,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)
                                 	ldi	zl, low(@3)
                                 	ldi	zh,high(@3)		
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CW	; subroutine,w
                                 	ldi	w, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CA	; subroutine,a
                                 	ldi	a0, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rcall	@0
                                 	.endmacro
                                 
                                 ; --- jump with arguments w,a,b ---
                                 .macro	JW	; subroutine,w
                                 	ldi	w, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JA	; subroutine,a
                                 	ldi	a0, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rjmp	@0
                                 	.endmacro
                                 .list
                                 
                                 .org	0
000000 c07b                      	rjmp	reset
                                 .org INT0addr			;Button 0
000002 940c 0030                 	jmp ext_int0
                                 .org INT1addr			;Button 1
000004 940c 003c                 	jmp ext_int1
                                 .org INT2addr			;Button 2
000006 940c 0048                 	jmp ext_int2
                                 .org INT3addr			;Button 3
000008 940c 0051                 	jmp ext_int3
                                 .org	OVF0addr		; timer overflow 0 interrupt vector
000020 c03d                      	rjmp	overflow0
                                 .org	0x30
                                 
                                 ; =============== interrupt service routines ================
                                 
                                 ext_int0:					;Button 0
000030 b61f                      	in	_sreg,SREG
                                 
000031 e022                      	ldi a0, 0b00000010
000032 2d3d                      	mov a1, d1
000033 1b32                      	sub a1, a0			;Tmax-2
                                 
000034 2d2b                      	mov a0, c3
                                 
000035 1b32                      	sub a1, a0			;Tmax-1-Tmin
000036 f410                      	brsh infcorrect		;Tmin<Tmax-1?
                                 
000037 be1f                      	out	SREG,_sreg
000038 9518                      	reti
                                 infcorrect:
000039 94b3                      	inc c3
00003a be1f                      	out	SREG,_sreg
00003b 9518                      	reti
                                 
                                 
                                 ext_int1:					;Button 1
00003c b61f                      	in	_sreg,SREG
                                 	
00003d e021                      	ldi a0, 0b00000001
00003e 2d3b                      	mov a1, c3
00003f 1b32                      	sub a1, a0
000040 ef2f                      	ldi a0, 0b11111111
000041 1b32                      	sub a1, a0
                                 
000042 f019                      	breq end2			;Tmin>0?
000043 94ba                      	dec c3
                                 	
000044 be1f                      	out	SREG,_sreg
000045 9518                      	reti
                                 end2:
000046 be1f                      	out	SREG,_sreg
000047 9518                      	reti
                                 
                                 
                                 ext_int2:					;Button 2
000048 b61f                      	in	_sreg,SREG
                                 
000049 e021                      	ldi a0, 0b00000001
00004a 0d2d                      	add a0, d1
                                 
00004b f019                      	breq end1			;Tmax<255?
00004c 94d3                      	inc d1
                                 
00004d be1f                      	out	SREG,_sreg
00004e 9518                      	reti
                                 end1: 
00004f be1f                      	out	SREG,_sreg
000050 9518                      	reti
                                 
                                 
                                 ext_int3:					;Button 3
000051 b61f                      	in	_sreg,SREG
000052 94da                      	dec d1
                                 
000053 e021                      	ldi a0, 0b00000001
000054 0d2b                      	add a0, c3
                                 	
000055 192d                      	sub a0, d1
000056 f410                      	brsh correctsup			;Tmin<Tmax-1?
                                 
000057 be1f                      	out	SREG,_sreg
000058 9518                      	reti
                                 correctsup:
000059 2cdb                      	mov d1, c3
00005a e021                      	ldi a0, 0b00000001
00005b 0ed2                      	add d1, a0
                                 
00005c be1f                      	out	SREG,_sreg
00005d 9518                      	reti
                                 
                                 overflow0:
00005e b61f                      	in _sreg,SREG
                                 
00005f d1a5                      	rcall	wire1_reset			; send a reset pulse
000060 ec2c
000061 d1cf                      	CA	wire1_write, skipROM
000062 eb2e
000063 d1cd                      	CA	wire1_write, readScratchpad	
000064 d1d7                      	rcall	wire1_read			; read temperature LSB
000065 fb27
000066 f993                      	MOVB b3,3,a0,7
000067 fb26
000068 f992                      	MOVB b3,2,a0,6
000069 fb25
00006a f991                      	MOVB b3,1,a0,5
00006b fb24
00006c f990                      	MOVB b3,0,a0,4	
00006d 2722                      	clr a0
00006e d1cd                      	rcall	wire1_read			; read temperature MSB
00006f fb22
000070 f996                      	MOVB b3,6,a0,2
000071 fb21
000072 f995                      	MOVB b3,5,a0,1
000073 fb20
000074 f994                      	MOVB b3,4,a0,0				;b3=Val entière de la température
                                 	
000075 d18f                      	rcall	wire1_reset			; send a reset pulse
000076 ec2c
000077 d1b9                      	CA	wire1_write, skipROM	; skip ROM identification
000078 e424
000079 d1b7                      	CA	wire1_write, convertT	; initiate temp conversion
00007a be1f                      	out	SREG,_sreg
00007b 9518                      	reti
                                 	
                                 ; ===================================== initialisation (reset) ================================
                                 reset: 
00007c ef0f
00007d bf0d
00007e e100
00007f bf0e                      	LDSP	RAMEND			; set up stack pointer (SP)
000080 d181                      	rcall	wire1_init		; initialize 1-wire(R) interface
                                 
000081 ef0f
000082 b902                      	OUTI	DDRE,0xff		; configure portE to output
                                 	;sbi	DDRE,SPEAKER	; make pin SPEAKER an output
                                 
000083 d045                      	rcall	LCD_init		; initialize the LCD
                                 
000084 e000                      	ldi r16,0x00	;configure portD as input
000085 bb01                      	out DDRD,r16
                                 
000086 ec0f
000087 bf09                      	OUTI	EIMSK,0b11001111
000088 ef0f
000089 9300 006a                 	OUTEI	EICRA,0b11111111	
00008b e001
00008c bf07                      	OUTI	TIMSK,(1<<TOIE0)
00008d e008
00008e bf00                      	OUTI	ASSR, (1<<AS0)	; clock from TOSC1 (external)
00008f e005
000090 bf03                      	OUTI	TCCR0,5			; CS0=1 CK/256
                                 
000091 e248                      	ldi a2, 40 
000092 2ed4                      	mov d1,a2	; Tmax
000093 e149                      	ldi a2,25
000094 2f94                      	mov b3,a2	; Tact
000095 e042                      	ldi a2,2
000096 2eb4                      	mov c3,a2	; Tmin
                                 
000097 d16d                      	rcall	wire1_reset			; send a reset pulse
000098 ec2c
000099 d197                      	CA	wire1_write, skipROM	; skip ROM identification
00009a e424
00009b d195                      	CA	wire1_write, convertT	; initiate temp conversion	
                                 
00009c 9478                      	sei							; set global interrupt
00009d c3de                      	rjmp main
                                 
                                 
                                 .include "lcd.asm"			; include the LCD routines
                                 
                                 ; purpose  LCD HD44780U library
                                 ; ATmega 128 and Atmel Studio 7.0 compliant
                                 
                                 ; === definitions ===
                                 .equ	LCD_IR	= 0x8000	; address LCD instruction reg
                                 .equ	LCD_DR	= 0xc000	; address LCD data register
                                 
                                 ; === subroutines ===
                                 LCD_wr_ir:
                                 ; in	w (byte to write to LCD IR)
00009e 9030 8000                 	lds	u, LCD_IR		; read IR to check busy flag  (bit7)
0000a0 fc37
0000a1 cffc                      	JB1	u,7,LCD_wr_ir	; Jump if Bit=1 (still busy)
0000a2 d003                      	rcall	lcd_4us		; delay to increment DRAM addr counter
0000a3 9300 8000                 	sts	LCD_IR, w		; store w in IR
0000a5 9508                      	ret
                                 	
                                 lcd_4us:
0000a6 d000                      	rcall	lcd_2us		; recursive call		
                                 lcd_2us:
0000a7 0000                      	nop					; rcall(3) + nop(1) + ret(4) = 8 cycles (2us)
0000a8 9508                      	ret
                                 
                                 LCD:
                                 LCD_putc:
0000a9 302d
0000aa f169                      	JK	a0,CR,LCD_cr	; Jump if a0=CR
0000ab 302a
0000ac f1a9                      	JK	a0,LF,LCD_lf	; Jump if a0=LF
                                 LCD_wr_dr:
                                 ; in	a0 (byte to write to LCD DR)
0000ad 9100 8000                 	lds	w, LCD_IR		; read IR to check busy flag  (bit7)
0000af fd07
0000b0 cffc                      	JB1	w,7,LCD_wr_dr	; Jump if Bit=1 (still busy)
0000b1 dff4                      	rcall	lcd_4us		; delay to increment DRAM addr counter
0000b2 9320 c000                 	sts	LCD_DR, a0		; store a0 in DR
0000b4 9508                      	ret	
                                 	
0000b5 e001
0000b6 cfe7                      LCD_clear:		JW	LCD_wr_ir, 0b00000001		; clear display
0000b7 e002
0000b8 cfe5                      LCD_home:		JW	LCD_wr_ir, 0b00000010		; return home
0000b9 e100
0000ba cfe3                      LCD_cursor_left:	JW	LCD_wr_ir, 0b00010000	; move cursor to left
0000bb e104
0000bc cfe1                      LCD_cursor_right:	JW	LCD_wr_ir, 0b00010100	; move cursor to right
0000bd e108
0000be cfdf                      LCD_display_left:	JW	LCD_wr_ir, 0b00011000	; shifts display to left
0000bf e10c
0000c0 cfdd                      LCD_display_right:	JW	LCD_wr_ir, 0b00011100	; shifts display to right
0000c1 e00d
0000c2 cfdb                      LCD_blink_on:		JW	LCD_wr_ir, 0b00001101	; Display=1,Cursor=0,Blink=1
0000c3 e00c
0000c4 cfd9                      LCD_blink_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
0000c5 e00e
0000c6 cfd7                      LCD_cursor_on:		JW	LCD_wr_ir, 0b00001110	; Display=1,Cursor=1,Blink=0
0000c7 e00c
0000c8 cfd5                      LCD_cursor_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
                                 		
                                 LCD_init:
0000c9 b705                      	in	w,MCUCR					; enable access to ext. SRAM
0000ca 6c00                      	sbr	w,(1<<SRE)+(1<<SRW10)
0000cb bf05                      	out	MCUCR,w
0000cc e001
0000cd dfd0                      	CW	LCD_wr_ir, 0b00000001	; clear display
0000ce e006
0000cf dfce                      	CW	LCD_wr_ir, 0b00000110	; entry mode set (Inc=1, Shift=0)
0000d0 e00c
0000d1 dfcc                      	CW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0	
0000d2 e308
0000d3 dfca                      	CW	LCD_wr_ir, 0b00111000	; 8bits=1, 2lines=1, 5x8dots=0
0000d4 9508                      	ret
                                 
                                 LCD_pos:
                                 ; in	a0 = position (0x00..0x0f first line, 0x40..0x4f second line)
0000d5 2f02                      	mov	w,a0
0000d6 6800                      	ori	w,0b10000000
0000d7 cfc6                      	rjmp	LCD_wr_ir
                                 
                                 LCD_cr:
                                 ; moving the cursor to the beginning of the line (carriage return)
0000d8 9100 8000                 	lds	w, LCD_IR			; read IR to check busy flag  (bit7)
0000da fd07
0000db cffc                      	JB1	w,7,LCD_cr			; Jump if Bit=1 (still busy)
0000dc 7400                      	andi	w,0b01000000	; keep bit6 (begin of line 1/2)
0000dd 6800                      	ori	w,0b10000000		; write address command
0000de dfc7                      	rcall	lcd_4us			; delay to increment DRAM addr counter
0000df 9300 8000                 	sts	LCD_IR,w			; store in IR
0000e1 9508                      	ret
                                 
                                 LCD_lf:
                                 ; moving the cursor to the beginning of the line 2 (line feed)
0000e2 932f                      	push	a0				; safeguard a0
0000e3 e420                      	ldi	a0,$40				; load position $40 (begin of line 2)
0000e4 dff0                      	rcall	LCD_pos			; set cursor position
0000e5 912f                      	pop	a0					; restore a0
                                 .include "printf.asm"		; include formatted print routines
0000e6 9508                      
                                 ; purpose library, formatted output generation
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 ; v2019.02 20180821 AxS supports SRAM input from 0x0260
                                 ;					through 0x02ff that should be reserved
                                 
                                 ; === description ===
                                 ; 
                                 ; The program "printf" interprets and prints formatted strings.
                                 ; The special formatting characters regognized are:
                                 ;
                                 ; FDEC	decimal number
                                 ; FHEX	hexadecimal number
                                 ; FBIN	binary number
                                 ; FFRAC	fixed fraction number
                                 ; FCHAR	single ASCII character
                                 ; FSTR	zero-terminated ASCII string
                                 ;	
                                 ; The special formatting characters are distinguished from normal 
                                 ; ASCII characters by having their bit7 set to 1.
                                 ;
                                 ; Signification of bit fields:
                                 ;
                                 ; b 	bytes		1..4 b bytes		2
                                 ; s 	sign		0(unsigned), 1(signed)	1
                                 ; i		integer digits	
                                 ; e 	base		2,,36			5
                                 ; dp 	dec. point	0..32			5
                                 ; $if	i=integer digits,  0=all digits,  1..15 digits 
                                 ;		f=fraction digits, 0=no fraction, 1..15 digits
                                 ;
                                 ; Formatting characters must be followed by an SRAM address (0..ff)
                                 ; that determines the origin of variables that must be printed (if any)
                                 ; FBIN,	sram
                                 ; FHEX,	sram
                                 ; FDEC,	sram
                                 ; FCHAR,sram
                                 ; FSTR,	sram
                                 ;
                                 ; The address 'sram' is a 1-byte constant. It addresses
                                 ; 	 0..1f	registers r0..r31, 
                                 ; 	20..3f	i/o ports, (need to be addressed with an offset of $20)
                                 ;	0x0260..0x02ff	SRAM
                                 ; Variables can be located into register and I/0s, and can also
                                 ; be stored into data SRAM at locations 0x0200 through 0x02ff. Any
                                 ; sram address higher than 0x0060 is assumed to be at (0x0260+address)
                                 ; from automatic address detection in _printf_formatted: and subsequent
                                 ; assignment to xh; xl keeps its value. Consequently, variables that are
                                 ; to be stored into SRAM and further printed by fprint must reside at
                                 ; 0x0200 up to 0x02ff, and must be addressed using a label. Usage: see
                                 ; file string1.asm, for example.
                                 
                                 ; The FFRAC formatting character must be followed by 
                                 ;	ONE sram address and 
                                 ;	TWO more formatting characters
                                 ; FFRAC,sram,dp,$if
                                 
                                 ; dp	decimal point position, 0=right, 32=left
                                 ; $if	format i.f, i=integer digits, f=fraction digits
                                 
                                 ; The special formatting characters use the following coding
                                 ;
                                 ; FDEC	11bb'iiis	i=0 all digits, i=1-7 digits
                                 ; FBIN	101i'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FHEX	1001'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 ; FREP	1000'0110
                                 ; FFUNC	1000'0111
                                 ;	1000'0010
                                 ;	1000'0011
                                 ; FESC	1000'0000
                                 
                                 ; examples
                                 ; formatting string			printing
                                 ; "a=",FDEC,a,0				1-byte variable a, unsigned decimal
                                 ; "a=",FDEC2,a,0			2-byte variable a (a1,a0), unsigend
                                 ; "a=",FDEC|FSIGN,a,0		1-byte variable 1, signed decimal
                                 ; "n=",FBIN,PIND+$20,0		i/o port, binary, notice offset of $20
                                 ; "f=",FFRAC4|FSIGN,a,16,$88,0	4-byte signed fixed-point fraction
                                 ;				dec.point at 16, 8 int.digits, 8 frac.digits	
                                 ; "f=",FFRAC2,a,16,$18,0		2-byte unsigned fixed-point fraction
                                 ;				dec.point at 16, 1 int.digits, 8 frac.digits	
                                 ; "a=",FDEC|FDIG5|FSIGN,a,0	1-byte variable, 5-digit, decimal, signed
                                 ; "a=",FDEC|FDIG5,a,0		1-byte variable, 5-digit, decimal, unsigned
                                 
                                 ; === registers modified ===
                                 ; e0,e1	used to transmit address of putc routine
                                 ; zh,zl	used as pointer to prog-memory
                                 
                                 ; === constants ==============================================
                                 
                                 .equ	FDEC	= 0b11000000	; 1-byte variable
                                 .equ	FDEC2	= 0b11010000	; 2-byte variable
                                 .equ	FDEC3	= 0b11100000	; 3-byte variable
                                 .equ	FDEC4	= 0b11110000	; 4-byte variable
                                 
                                 .equ	FBIN	= 0b10100000
                                 .equ	FHEX	= 0b10010100	; 1-byte variable
                                 .equ	FHEX2	= 0b10011000	; 2-byte variable
                                 .equ	FHEX3	= 0b10011100	; 3-byte variable
                                 .equ	FHEX4	= 0b10010000	; 4-byte variable
                                 
                                 .equ	FFRAC	= 0b10001000	; 1-byte variable
                                 .equ	FFRAC2	= 0b10001010	; 2-byte variable
                                 .equ	FFRAC3	= 0b10001100	; 3-byte variable
                                 .equ	FFRAC4	= 0b10001110	; 4-byte variable
                                 
                                 .equ	FCHAR	= 0b10000100
                                 .equ	FSTR	= 0b10000101
                                 
                                 .equ	FSIGN	= 0b00000001
                                 
                                 .equ	FDIG1	= 1<<1
                                 .equ	FDIG2	= 2<<1
                                 .equ	FDIG3	= 3<<1	
                                 .equ	FDIG4	= 4<<1
                                 .equ	FDIG5	= 5<<1
                                 .equ	FDIG6	= 6<<1
                                 .equ	FDIG7	= 7<<1
                                 
                                 ; ===macro ====================================================
                                 
                                 .macro	PRINTF			; putc function (UART, LCD...)
                                 	ldi	w, low(@0)		; address of "putc" in e1:d0
                                 	mov	e0,w
                                 	ldi	w,high(@0)
                                 	mov	e1,w
                                 	rcall	_printf
                                 	.endmacro
                                 
                                 ; mod	y,z
                                 
                                 
                                 ; === routines ================================================
                                 
                                 _printf:
0000e7 91ff
0000e8 91ef                      	POPZ			; z points to begin of "string"
0000e9 0fee
0000ea 1fff                      	MUL2Z			; multiply Z by two, (word ptr -> byte ptr)
0000eb 93af
0000ec 93bf                      	PUSHX
                                 		
                                 _printf_read:
0000ed 95c8                      	lpm				; places prog_mem(Z) into r0 (=c)
0000ee 9631                      	adiw	zl,1	; increment pointer Z
0000ef 2000                      	tst	r0			; test for ZERO (=end of string)
0000f0 f021                      	breq	_printf_end	; char=0 indicates end of ascii string
0000f1 f04a                      	brmi	_printf_formatted ; bit7=1 indicates formatting character
0000f2 2d00                      	mov	w,r0
0000f3 d017                      	rcall	_putw	; display the character
0000f4 cff8                      	rjmp	_printf_read	; read next character in the string
                                 	
                                 _printf_end:
0000f5 9631                      	adiw	zl,1	; point to the next character
0000f6 95f6
0000f7 95e7                      	DIV2Z			; divide by 2 (byte ptr -> word ptr)
0000f8 91bf
0000f9 91af                      	POPX
0000fa 9409                      	ijmp			; return to instruction after "string"
                                 
                                 _printf_formatted:
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 
0000fb fa00                      	bst	r0,0		; store sign in T
0000fc 2d00                      	mov	w,r0		; store formatting character in w
0000fd 95c8                      	lpm	
0000fe 2da0                      	mov	xl,r0		; load x-pointer with SRAM address
0000ff 36a0                      	cpi	xl,0x60
000100 f010                      	brlo rio_space
                                 dataram_space:		; variable originates from SRAM memory
000101 e0b2                      	ldi	xh,0x02		;>addresses are limited to 0x0260 through 0x02ff
000102 c001                      	rjmp space_detect_end	;>that enables automatic detection of the origin
                                 rio_space:			; variable originates from reg or I/O space 
000103 27bb                      	clr	xh			; clear high-byte, addresses are 0x0000 through 0x003f (0x005f)
                                 space_detect_end:
000104 9631                       	adiw	zl,1	; increment pointer Z
                                 
                                 ;	JB1	w,6,_putdec
                                 ;	JB1	w,5,_putbin
                                 ;	JB1	w,4,_puthex
                                 ;	JB1	w,3,_putfrac
000105 3804
000106 f079                      	JK	w,FCHAR,_putchar
000107 3805
000108 f081                      	JK	w,FSTR ,_putstr
000109 c015                      	rjmp	_putnum
                                 	
00010a cfe2                      	rjmp	_printf_read	
                                 
                                 ; === putc (put character) ===============================
                                 ; in	w	character to put
                                 ;	e1,e0	address of output routine (UART, LCD putc)
                                 _putw:
00010b 932f
00010c 93ff
00010d 93ef                      	PUSH3	a0,zh,zl
00010e 2de4
00010f 2df5
000110 2f20                      	MOV3	a0,zh,zl, w,e1,e0
000111 9509                      	icall			; indirect call to "putc"
000112 91ef
000113 91ff
000114 912f                      	POP3	a0,zh,zl
000115 9508                      	ret
                                 
                                 ; === putchar (put character) ============================
                                 ; in	x	pointer to character to put
                                 _putchar:
000116 910c                      	ld	w,x
000117 dff3                      	rcall	_putw
000118 cfd4                      	rjmp	_printf_read
                                 	
                                 ; === putstr (put string) ================================
                                 ; in	x	pointer to ascii string
                                 ;	b3,b2	address of output routine (UART, LCD putc)
                                 _putstr:
000119 910d                      	ld	w,x+
00011a 2300                      	tst	w
00011b f409                      	brne	PC+2
00011c cfd0                      	rjmp	_printf_read
00011d dfed                      	rcall	_putw
00011e cffa                      	rjmp	_putstr
                                 
                                 ; === putnum (dec/bin/hex/frac) ===========================
                                 ; in	x	pointer to SRAM variable to print
                                 ; 	r0	formatting character
                                 	
                                 _putnum:
00011f 935f
000120 934f
000121 933f
000122 932f                      	PUSH4	a3,a2,a1,a0	; safeguard a
000123 939f
000124 938f
000125 937f
000126 936f                      	PUSH4	b3,b2,b1,b0	; safeguard b	
000127 912d
000128 913d
000129 914d
00012a 915d                      	LDX4	a3,a2,a1,a0	; load operand to print into a
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FRACT	1000'1bbs
                                 
00012b fd06
00012c c006                      	JB1	w,6,_putdec
00012d fd05
00012e c00f                      	JB1	w,5,_putbin
00012f fd04
000130 c010                      	JB1	w,4,_puthex
000131 fd03
000132 c019                      	JB1	w,3,_putfrac
                                 
                                 ; FDEC	11bb'iiis
                                 _putdec:
000133 e06a                      	ldi	b0,10		; b0 = base (10)
                                 
000134 2f70                      	mov	b1,w
000135 9576                      	lsr	b1
000136 7077                      	andi	b1,0b111	
000137 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
000138 e080                      	ldi	b2,0		; b2 = dec. point position = 0 (right)
                                 	
000139 2f90                      	mov	b3,w
00013a 9592                      	swap	b3
00013b 7093                      	andi	b3,0b11
00013c 9593                      	inc	b3			; b3 = number of bytes (1..4)
00013d c01a                      	rjmp	_getnum	; get number of digits (iii)
                                 
                                 ; FBIN	101i'iiis	addr
                                 _putbin:	
00013e e062                      	ldi	b0,2		; b0 = base (2)
00013f e094                      	ldi	b3,4		; b3 = number of bytes (4)	
000140 c003                      	rjmp	_getdig	; get number of digits (iii)
                                 
                                 ; FHEX	1001'iiis	addr
                                 _puthex:	
000141 e160                      	ldi	b0,16		; b0 = base (16)
000142 e094                      	ldi	b3,4		; b3 = number of bytes (4)
000143 c000                      	rjmp	_getdig
                                 
                                 _getdig:
000144 2f70                      	mov	b1,w
000145 9576                      	lsr	b1
000146 7077                      	andi	b1,0b111
000147 f409                      	brne	PC+2
000148 e078                      	ldi	b1,8		; if b1=0 then 8-digits
000149 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
00014a e080                      	ldi	b2, 0		; b2 = dec. point position = 0 (right)
00014b c00c                      	rjmp	_getnum
                                 
                                 ; FFRAC	1000'1bbs	addr	 00dd'dddd, 	iiii'ffff
                                 	
                                 _putfrac:
00014c e06a                      	ldi	b0,10		; base=10	
00014d 95c8                      	lpm
00014e 2d80                      	mov	b2,r0		; load dec.point position
00014f 9631                      	adiw	zl,1	; increment char pointer
000150 95c8                      	lpm
000151 2d70                      	mov	b1,r0		; load ii.ff format
000152 9631                      	adiw	zl,1	; increment char pointer
                                 	
000153 2f90                      	mov	b3,w
000154 9595                      	asr	b3
000155 7093                      	andi	b3,0b11
000156 9593                      	inc	b3			; b3 = number of bytes (1..4)
                                 
000157 c000                      	rjmp	_getnum
                                 
                                 _getnum:
                                 ; in 	a	4-byte variable
                                 ; 	b3	number of bytes (1..4)
                                 ;	T	sign, 0=unsigned, 1=signed
                                 
000158 3094
000159 f081                      	JK	b3,4,_printf_4b
00015a 3093
00015b f051                      	JK	b3,3,_printf_3b
00015c 3092
00015d f021                      	JK	b3,2,_printf_2b	
                                 	
                                 _printf_1b:			; sign extension
00015e 2733                      	clr	a1
00015f f416                      	brtc	PC+3	; T=1 sign extension
000160 fd27                      	sbrc	a0,7
000161 ef3f                      	ldi	a1,0xff
                                 _printf_2b:
000162 2744                      	clr	a2
000163 f416                      	brtc	PC+3	; T=1 sign extension	
000164 fd37                      	sbrc	a1,7
000165 ef4f                      	ldi	a2,0xff
                                 _printf_3b:	
000166 2755                      	clr	a3
000167 f416                      	brtc	PC+3	; T=1 sign extension
000168 fd47                      	sbrc	a2,7
000169 ef5f                      	ldi	a3,0xff
                                 _printf_4b:
                                 
00016a d009                      	rcall	_ftoa		; float to ascii
00016b 916f
00016c 917f
00016d 918f
00016e 919f                      	POP4	b3,b2,b1,b0	; restore b
00016f 912f
000170 913f
000171 914f
000172 915f                      	POP4	a3,a2,a1,a0	; restore a
                                 	
000173 cf79                      	rjmp	_printf_read
                                 
                                 ; ===============================================
                                 ; func	ftoa
                                 ; converts a fixed-point fractional number to an ascii string
                                 ; author (c) Raphael Holzer
                                 ;
                                 ; in	a3-a0	variable to print
                                 ;	b0	base, 2 to 36, but usually decimal (10)
                                 ;	b1	number of digits to print ii.ff
                                 ; 	b2	position of the decimal point (0=right, 32=left)
                                 ;	T	sign (T=0 unsiged, T=1 signed)
                                 
                                 _ftoa:
000174 92cf                      	push	d0
000175 92bf
000176 92af
000177 929f
000178 928f                      	PUSH4	c3,c2,c1,c0	; c = fraction part, a = integer part
000179 18bb
00017a 24aa
00017b 2499
00017c 2488                      	CLR4	c3,c2,c1,c0	; clear fraction part
                                 
00017d f486                      	brtc	_ftoa_plus	; if T=0 then unsigned
00017e 94e8                      	clt
00017f 2355                      	tst	a3				; if MSb(a)=1 then a=-a
000180 f46a                      	brpl	_ftoa_plus
000181 9468                      	set					; T=1 (minus)
000182 2377                      	tst	b1
000183 f009                      	breq	PC+2		; if b1=0 the print ALL digits
000184 5170                      	subi	b1,0x10		; decrease int digits
000185 9550
000186 9540
000187 9530
000188 9520
000189 ef0f
00018a 1b20
00018b 0b30
00018c 0b40
00018d 0b50                      	NEG4	a3,a2,a1,a0	; negate a
                                 _ftoa_plus:	
00018e 2388                      	tst	b2				; b0=0 (only integer part)
00018f f051                      	breq	_ftoa_int	
                                 _ftoa_shift:	
000190 9555
000191 9547
000192 9537
000193 9527                      	ASR4	a3,a2,a1,a0	; a = integer part	
000194 94b7
000195 94a7
000196 9497
000197 9487                      	ROR4	c3,c2,c1,c0	; c = fraction part
000198 958a
000199 f7b1                      	DJNZ	b2,_ftoa_shift
                                 _ftoa_int:
00019a 937f                      	push	b1			; ii.ff (ii=int digits)
00019b 9572                      	swap	b1
00019c 707f                      	andi	b1,0x0f
                                 	
00019d e20e                      	ldi	w,'.'			; push decimal point
00019e 930f                      	push	w
                                 _ftoa_int1:
00019f d045                      	rcall	_div41		; int=int/10
0001a0 2d0c                      	mov	w,d0			; d=reminder
0001a1 d030                      	rcall	_hex2asc
0001a2 930f                      	push	w			; push rem(int/10)
0001a3 2700
0001a4 1720
0001a5 0730
0001a6 0740
0001a7 0750                      	TST4	a3,a2,a1,a0	; (int/10)=?
0001a8 f029                      	breq	_ftoa_space	; (int/10)=0 then finished
0001a9 2377                      	tst	b1
0001aa f3a1                      	breq	_ftoa_int1	; if b1=0 then print ALL int-digits
0001ab 957a
0001ac f791                      	DJNZ	b1,_ftoa_int1
0001ad c007                      	rjmp	_ftoa_sign
                                 _ftoa_space:
0001ae 2377                      	tst	b1				; if b1=0 then print ALL int-digits
0001af f029                      	breq	_ftoa_sign
0001b0 957a                      	dec	b1
0001b1 f019                      	breq	_ftoa_sign
0001b2 e200                      	ldi	w,' '			; write spaces
0001b3 df57                      	rcall	_putw	
0001b4 cff9                      	rjmp	_ftoa_space
                                 _ftoa_sign:
0001b5 f416                      	brtc	PC+3		; if T=1 then write 'minus'
0001b6 e20d                      	ldi	w,'-'
0001b7 df53                      	rcall	_putw
                                 _ftoa_int3:
0001b8 910f                      	pop	w
0001b9 320e                      	cpi	w,'.'
0001ba f011                      	breq	PC+3
0001bb df4f                      	rcall	_putw
0001bc cffb                      	rjmp	_ftoa_int3
                                 
0001bd 917f                      	pop	b1				; ii.ff (ff=frac digits)
0001be 707f                      	andi	b1,0x0f
0001bf 2377                      	tst	b1
0001c0 f059                      	breq	_ftoa_end
                                 _ftoa_point:	
0001c1 df49                      	rcall	_putw		; write decimal point
0001c2 2d28
0001c3 2d39
0001c4 2d4a
0001c5 2d5b                      	MOV4	a3,a2,a1,a0, c3,c2,c1,c0		
                                 _ftoa_frac:
0001c6 d011                      	rcall	_mul41		; d.frac=10*frac
0001c7 2d0c                      	mov	w,d0
0001c8 d009                      	rcall	_hex2asc
0001c9 df41                      	rcall	_putw
0001ca 957a
0001cb f7d1                      	DJNZ	b1,_ftoa_frac
                                 _ftoa_end:
0001cc 908f
0001cd 909f
0001ce 90af
0001cf 90bf                      	POP4	c3,c2,c1,c0
0001d0 90cf                      	pop	d0
0001d1 9508                      	ret
                                 
                                 ; === hexadecimal to ascii ===
                                 ; in	w
                                 _hex2asc:
0001d2 300a                      	cpi	w,10
0001d3 f410                      	brsh	PC+3
0001d4 5d00                      	addi	w,'0'
0001d5 9508                      	ret
0001d6 5a09                      	addi	w,('a'-10)
0001d7 9508                      	ret
                                 
                                 ; === multiply 4byte*1byte ===
                                 ; funct mul41
                                 ; multiplies a3-a0 (4-byte) by b0 (1-byte)
                                 ; author (c) Raphael Holzer, EPFL
                                 ; 
                                 ; in	a3..a0	multiplicand (argument to multiply)
                                 ;	b0	multiplier
                                 ; out	a3..a0	result
                                 ; 	d0	result MSB (byte 4)
                                 ;
0001d8 24cc                      _mul41:	clr	d0			; clear byte4 of result
0001d9 e200                      	ldi	w,32			; load bit counter
0001da 9488                      __m41:	clc				; clear carry
0001db fd20                      	sbrc	a0,0		; skip addition if LSB=0
0001dc 0ec6                      	add	d0,b0			; add b to MSB of a
0001dd 94c7
0001de 9557
0001df 9547
0001e0 9537
0001e1 9527                      	ROR5	d0,a3,a2,a1,a0	; shift-right c, LSB (of b) into carry
0001e2 950a
0001e3 f7b1                      	DJNZ	w,__m41		; Decrement and Jump if bit-count Not Zero
0001e4 9508                      	ret
                                 
                                 ; === divide 4byte/1byte ===
                                 ; func div41
                                 ; in	a0..a3 	divident (argument to divide)
                                 ;	b0 	divider
                                 ; out	a0..a3 	result 
                                 ;	d0	reminder
                                 ;
0001e5 24cc                      _div41:	clr	d0			; d will contain the remainder
0001e6 e200                      	ldi	w,32			; load bit counter
0001e7 1f22
0001e8 1f33
0001e9 1f44
0001ea 1f55
0001eb 1ccc                      __d41:	ROL5	d0,a3,a2,a1,a0	; shift carry into result c
0001ec 1ac6                      	sub	d0, b0			; subtract b from remainder
0001ed f408                      	brcc	PC+2	
0001ee 0ec6                      	add	d0, b0			; restore if remainder became negative
0001ef 950a
0001f0 f7b1                      	DJNZ	w,__d41		; Decrement and Jump if bit-count Not Zero
0001f1 1f22
0001f2 1f33
0001f3 1f44
0001f4 1f55                      	ROL4	a3,a2,a1,a0	; last shift (carry into result c)
0001f5 9550
0001f6 9540
0001f7 9530
0001f8 9520                      	COM4	a3,a2,a1,a0	; complement result
0001f9 9508                      	ret
                                 .include "wire1.asm"		; include Dallas 1-wire(R) routines
                                 
                                 ; purpose Dallas 1-wire(R) interface library
                                 
                                 ; === definitions ===
                                 .equ	DQ_port	= PORTB
                                 .equ	DQ_pin	= DQ
                                 
                                 .equ	DS18B20		= 0x28
                                 
                                 .equ	readROM		= 0x33
                                 .equ	matchROM	= 0x55
                                 .equ	skipROM		= 0xcc
                                 .equ	searchROM	= 0xf0
                                 .equ	alarmSearch	= 0xec
                                 
                                 .equ	writeScratchpad	= 0x4e
                                 .equ	readScratchpad	= 0xbe
                                 .equ	copyScratchpad	= 0x48
                                 .equ	convertT	= 0x44
                                 .equ	recallE2	= 0xb8
                                 .equ	readPowerSupply	= 0xb4
                                 
                                 ; === routines ===
                                 
                                 .macro	WIRE1	; t0,t1,t2
                                 	sbi	DQ_port-1,DQ_pin	; pull DQ low (DDR=1 output)
                                 	ldi	w,(@0+1)/2	
                                 	rcall	wire1_wait		; wait low time (t0)
                                 	cbi	DQ_port-1,DQ_pin	; release DQ (DDR=0 input)
                                 	ldi	w,(@1+1)/2	
                                 	rcall	wire1_wait		; wait high time (t1)
                                 	in	w,DQ_port-2			; sample line (PINx=PORTx-2)
                                 	bst	w,DQ_pin			; store result in T
                                 	ldi	w,(@2+1)/2	
                                 	rcall	wire1_wait		; wait separation time (t2)
                                 	ret
                                 	.endmacro	
                                 
                                 wire1_wait:
0001fa 950a                      	dec	w					; loop time 2usec
0001fb 0000                      	nop
0001fc 0000                      	nop
0001fd 0000                      	nop
0001fe 0000                      	nop
0001ff 0000                      	nop
000200 f7c9                      	brne	wire1_wait
000201 9508                      	ret
                                 
                                 wire1_init:
000202 98c5                      	cbi	DQ_port,  DQ_pin	; PORT=0 low (for pull-down)
000203 98bd                      	cbi	DQ_port-1,DQ_pin	; DDR=0 (input hi Z)
000204 9508                      	ret
                                 	
000205 9abd
000206 ef00
000207 dff2
000208 98bd
000209 e203
00020a dfef
00020b b306
00020c fb05
00020d ec0d
00020e dfeb
00020f 9508                      wire1_reset:	WIRE1	480,70,410
000210 9abd
000211 e10c
000212 dfe7
000213 98bd
000214 e002
000215 dfe4
000216 b306
000217 fb05
000218 e001
000219 dfe0
00021a 9508                      wire1_write0:	WIRE1	56,4,1
00021b 9abd
00021c e001
00021d dfdc
00021e 98bd
00021f e10e
000220 dfd9
000221 b306
000222 fb05
000223 e001
000224 dfd5
000225 9508                      wire1_write1:	WIRE1	1,59,1
000226 9abd
000227 e001
000228 dfd1
000229 98bd
00022a e007
00022b dfce
00022c b306
00022d fb05
00022e e107
00022f dfca
000230 9508                      wire1_read1:	WIRE1	1,14,45
                                 	
                                 wire1_write:
000231 933f                      	push	a1
000232 e038                      	ldi	a1,8
000233 9527                      	ror	a0
                                 
000234 f410                      	brcc	PC+3				; if C=1 then wire1, else wire0
000235 dfe5                      	rcall	wire1_write1
000236 c001                      	rjmp	PC+2
000237 dfd8                      	rcall	wire1_write0
                                 
000238 953a
000239 f7c9                      	DJNZ	a1,wire1_write+2	; dec and jump if not zero
00023a 913f                      	pop	a1	
00023b 9508                      	ret
                                 
                                 wire1_read:
00023c 933f                      	push	a1
00023d e038                      	ldi	a1,8
00023e 9527                      	ror	a0
00023f dfe6                      	rcall	wire1_read1			; returns result in T
000240 f927                      	bld	a0,7					; move T to MSb
000241 953a
000242 f7d9                      	DJNZ	a1,wire1_read+2		; dec and jump if not zero
000243 913f                      	pop	a1	
000244 9508                      	ret
                                 	
                                 wire1_crc:
000245 e109                      	ldi	w,0b00011001
000246 e048                      	ldi	a2,8
000247 9527                      crc1:	ror	a0
000248 f408                      	brcc	PC+2
000249 2730                      	eor	a1,w
00024a fb30                      	bst	a1,0
00024b 9537                      	ror	a1
00024c f937                      	bld	a1,7
00024d 954a
00024e f7c1                      	DJNZ	a2,crc1
                                 .include "math.asm"			; include math routines
00024f 9508                      
                                 ; purpose library, mathematical routines
                                 ; copyright R.Holzer
                                 
                                 ; === unsigned multiplication (c=a*b) ===
                                 
000250 2499                      mul11:	clr	c1			; clear upper half of result c
000251 2e86                      	mov	c0,b0			; place b in lower half of c
000252 9486                      	lsr	c0			; shift LSB (of b) into carry
000253 e008                      	ldi	w,8			; load bit counter
000254 f408                      _m11:	brcc	PC+2			; skip addition if carry=0
000255 0e92                      	add	c1,a0			; add a to upper half of c
000256 9497
000257 9487                      	ROR2	c1,c0			; shift-right c, LSB (of b) into carry
000258 950a
000259 f7d1                      	DJNZ	w,_m11			; Decrement and Jump if bit-count Not Zero
00025a 9508                      	ret
                                 
00025b 18aa
00025c 2499                      mul21:	CLR2	c2,c1			; clear upper half of result c
00025d 2e86                      	mov	c0,b0			; place b in lower half of c
00025e 9486                      	lsr	c0			; shift LSB (of b) into carry
00025f e008                      	ldi	w,8			; load bit counter
000260 f410                      _m21:	brcc	PC+3			; skip addition if carry=0
000261 0e92
000262 1ea3                      	ADD2	c2,c1, a1,a0		; add a to upper half of c
000263 94a7
000264 9497
000265 9487                      	ROR3	c2,c1,c0		; shift-right c, LSB (of b) into carry
000266 950a
000267 f7c1                      	DJNZ	w,_m21			; Decrement and Jump if bit-count Not Zero
000268 9508                      	ret
                                 
000269 18bb
00026a 24aa                      mul22:	CLR2	c3,c2			; clear upper half of result c
00026b 2e86
00026c 2e97                      	MOV2	c1,c0, b1,b0		; place b in lower half of c
00026d 9496
00026e 9487                      	LSR2	c1,c0			; shift LSB (of b) into carry
00026f e100                      	ldi	w,16			; load bit counter
000270 f410                      _m22:	brcc	PC+3			; skip addition if carry=0
000271 0ea2
000272 1eb3                      	ADD2	c3,c2, a1,a0		; add a to upper half of c
000273 94b7
000274 94a7
000275 9497
000276 9487                      	ROR4	c3,c2,c1,c0		; shift-right c, LSB (of b) into carry
000277 950a
000278 f7b9                      	DJNZ	w,_m22			; Decrement and Jump if bit-count Not Zero
000279 9508                      	ret
                                 
00027a 18bb
00027b 24aa
00027c 2499                      mul31:	CLR3	c3,c2,c1		; clear upper half of result c
00027d 2e86                      	mov	c0,b0			; place b in lower half of c
00027e 9486                      	lsr	c0			; shift LSB (of b) into carry
00027f e008                      	ldi	w,8			; load bit counter
000280 f418                      _m31:	brcc	PC+4			; skip addition if carry=0
000281 0e92
000282 1ea3
000283 1eb4                      	ADD3	c3,c2,c1, a2,a1,a0	; add a to upper half of c
000284 94b7
000285 94a7
000286 9497
000287 9487                      	ROR4	c3,c2,c1,c0		; shift-right c, LSB (of b) into carry
000288 950a
000289 f7b1                      	DJNZ	w,_m31			; Decrement and Jump if bit-count Not Zero
00028a 9508                      	ret
                                 
00028b 18cc
00028c 24bb
00028d 24aa                      mul32:	CLR3	d0,c3,c2		; clear upper half of result c
00028e 2e86
00028f 2e97                      	MOV2	c1,c0, b1,b0		; place b in lower half of c
000290 9496
000291 9487                      	LSR2	c1,c0			; shift LSB (of b) into carry
000292 e100                      	ldi	w,16			; load bit counter
000293 f418                      _m32:	brcc	PC+4			; skip addition if carry=0
000294 0ea2
000295 1eb3
000296 1ec4                      	ADD3	d0,c3,c2, a2,a1,a0	; add a to upper half of c
000297 94c7
000298 94b7
000299 94a7
00029a 9497
00029b 9487                      	ROR5	d0,c3,c2,c1,c0		; shift-right c, LSB (of b) into carry
00029c 950a
00029d f7a9                      	DJNZ	w,_m32			; Decrement and Jump if bit-count Not Zero
00029e 9508                      	ret
                                 	
00029f 18dd
0002a0 24cc
0002a1 24bb                      mul33:	CLR3	d1,d0,c3		; clear upper half of result c
0002a2 2e86
0002a3 2e97
0002a4 2ea8                      	MOV3	c2,c1,c0, b2,b1,b0	; place b in lower half of c
0002a5 94a6
0002a6 9497
0002a7 9487                      	LSR3	c2,c1,c0		; shift LSB (of b) into carry
0002a8 e108                      	ldi	w,24			; load bit counter
0002a9 f418                      _m33:	brcc	PC+4			; skip addition if carry=0
0002aa 0eb2
0002ab 1ec3
0002ac 1ed4                      	ADD3	d1,d0,c3, a2,a1,a0	; add a to upper half of c
0002ad 94d7
0002ae 94c7
0002af 94b7
0002b0 94a7
0002b1 9497
0002b2 9487                      	ROR6	d1,d0,c3,c2,c1,c0	; shift-right c, LSB (of b) into carry
0002b3 950a
0002b4 f7a1                      	DJNZ	w,_m33			; Decrement and Jump if bit-count Not Zero
0002b5 9508                      	ret
                                 
0002b6 18cc
0002b7 24bb
0002b8 24aa
0002b9 2499                      mul41:	CLR4	d0,c3,c2,c1		; clear upper half of result c
0002ba 2e86                      	mov	c0,b0			; place b in lower half of c
0002bb 9486                      	lsr	c0			; shift LSB (of b) into carry
0002bc e008                      	ldi	w,8			; load bit counter
0002bd f420                      _m41:	brcc	PC+5			; skip addition if carry=0
0002be 0e92
0002bf 1ea3
0002c0 1eb4
0002c1 1ec5                      	ADD4	d0,c3,c2,c1, a3,a2,a1,a0; add a to upper half of c
0002c2 94c7
0002c3 94b7
0002c4 94a7
0002c5 9497
0002c6 9487                      	ROR5	d0,c3,c2,c1,c0		; shift-right c, LSB (of b) into carry
0002c7 950a
0002c8 f7a1                      	DJNZ	w,_m41			; Decrement and Jump if bit-count Not Zero
0002c9 9508                      	ret
                                 
0002ca 18dd
0002cb 24cc
0002cc 24bb
0002cd 24aa                      mul42:	CLR4	d1,d0,c3,c2		; clear upper half of result c
0002ce 2e86
0002cf 2e97                      	MOV2	c1,c0, b1,b0			; place b in lower half of c
0002d0 9496
0002d1 9487                      	LSR2	c1,c0			; shift LSB (of b) into carry
0002d2 e100                      	ldi	w,16			; load bit counter
0002d3 f420                      _m42:	brcc	PC+5			; skip addition if carry=0
0002d4 0ea2
0002d5 1eb3
0002d6 1ec4
0002d7 1ed5                      	ADD4	d1,d0,c3,c2, a3,a2,a1,a0; add a to upper half of c
0002d8 94d7
0002d9 94c7
0002da 94b7
0002db 94a7
0002dc 9497
0002dd 9487                      	ROR6	d1,d0,c3,c2,c1,c0	; shift-right c, LSB (of b) into carry
0002de 950a
0002df f799                      	DJNZ	w,_m42			; Decrement and Jump if bit-count Not Zero
0002e0 9508                      	ret
                                 
0002e1 18ee
0002e2 24dd
0002e3 24cc
0002e4 24bb                      mul43:	CLR4	d2,d1,d0,c3		; clear upper half of result c
0002e5 2e86
0002e6 2e97
0002e7 2ea8                      	MOV3	c2,c1,c0, b2,b1,b0	; place b in lower half of c
0002e8 94a6
0002e9 9497
0002ea 9487                      	LSR3	c2,c1,c0		; shift LSB (of b) into carry
0002eb e108                      	ldi	w,24			; load bit counter
0002ec f420                      _m43:	brcc	PC+5			; skip addition if carry=0
0002ed 0eb2
0002ee 1ec3
0002ef 1ed4
0002f0 1ee5                      	ADD4	d2,d1,d0,c3, a3,a2,a1,a0; add a to upper half of c
0002f1 94e7
0002f2 94d7
0002f3 94c7
0002f4 94b7
0002f5 94a7
0002f6 9497
0002f7 9487                      	ROR7	d2,d1,d0,c3,c2,c1,c0	; shift-right c, LSB (of b) into carry
0002f8 950a
0002f9 f791                      	DJNZ	w,_m43			; Decrement and Jump if bit-count Not Zero
0002fa 9508                      	ret
                                 
0002fb 18ff
0002fc 24ee
0002fd 24dd
0002fe 24cc                      mul44:	CLR4	d3,d2,d1,d0		; clear upper half of result c
0002ff 2e86
000300 2e97
000301 2ea8
000302 2eb9                      	MOV4	c3,c2,c1,c0, b3,b2,b1,b0; place b in lower half of c
000303 94b6
000304 94a7
000305 9497
000306 9487                      	LSR4	c3,c2,c1,c0		; shift LSB (of b) into carry
000307 e200                      	ldi	w,32			; load bit counter
000308 f420                      _m44:	brcc	PC+5			; skip addition if carry=0
000309 0ec2
00030a 1ed3
00030b 1ee4
00030c 1ef5                      	ADD4	d3,d2,d1,d0, a3,a2,a1,a0; add a to upper half of c
00030d 94f7
00030e 94e7
00030f 94d7
000310 94c7
000311 94b7
000312 94a7
000313 9497
000314 9487                      	ROR8	d3,d2,d1,d0,c3,c2,c1,c0	; shift-right c, LSB (of b) into carry
000315 950a
000316 f789                      	DJNZ	w,_m44			; Decrement and Jump if bit-count Not Zero
000317 9508                      	ret
                                 
                                 ; === signed multiplication ===		
000318 df37                      mul11s: rcall	mul11
000319 fd27                      	sbrc	a0,7
00031a 1a96                      	sub	c1,b0
00031b fd67                      	sbrc	b0,7
00031c 1a92                      	sub	c1,a0
00031d 9508                      	ret
                                 
00031e df4a                      mul22s: rcall	mul22
00031f ff37                      	sbrs	a1,7
000320 c002                      	rjmp	PC+3
000321 1aa6
000322 0ab7                      	SUB2	c3,c2, b1,b0
000323 ff77                      	sbrs	b1,7
000324 c002                      	rjmp	PC+3	
000325 1aa2
000326 0ab3                      	SUB2	c3,c2, a1,a0
000327 9508                      	ret
                                 
000328 df76                      mul33s: rcall	mul33
000329 ff47                      	sbrs	a2,7
00032a c003                      	rjmp	PC+4
00032b 1ab6
00032c 0ac7
00032d 0ad8                      	SUB3	d1,d0,c3, b2,b1,b0
00032e ff87                      	sbrs	b2,7
00032f c003                      	rjmp	PC+4
000330 1ab2
000331 0ac3
000332 0ad4                      	SUB3	d1,d0,c3, a2,a1,a0
000333 9508                      	ret
                                 
000334 dfc6                      mul44s: rcall	mul44
000335 ff57                      	sbrs	a3,7
000336 c004                      	rjmp	PC+5
000337 1ac6
000338 0ad7
000339 0ae8
00033a 0af9                      	SUB4	d3,d2,d1,d0, b3,b2,b1,b0
00033b ff97                      	sbrs	b3,7
00033c c004                      	rjmp	PC+5
00033d 1ac2
00033e 0ad3
00033f 0ae4
000340 0af5                      	SUB4	d3,d2,d1,d0, a3,a2,a1,a0
000341 9508                      	ret
                                 
                                 ; === unsigned division c=a/b ===
000342 2e82                      div11:	mov	c0,a0			; c will contain the result
000343 24cc                      	clr	d0			; d will contain the remainder
000344 e008                      	ldi	w,8			; load bit counter
000345 1c88
000346 1ccc                      _d11:	ROL2	d0,c0			; shift carry into result c
000347 1ac6                      	sub	d0,b0			; subtract b from remainder
000348 f408                      	brcc	PC+2	
000349 0ec6                      	add	d0,b0			; restore if remainder became negative
00034a 950a
00034b f7c9                      	DJNZ	w,_d11			; Decrement and Jump if bit-count Not Zero
00034c 1c88                      	rol	c0			; last shift (C into result c)
00034d 9480                      	com	c0			; complement result
00034e 9508                      	ret
                                 
00034f 2e82
000350 2e93                      div21:	MOV2	c1,c0, a1,a0		; c will contain the result
000351 24cc                      	clr	d0			; d will contain the remainder
000352 e100                      	ldi	w,16			; load bit counter
000353 1c88
000354 1c99
000355 1ccc                      _d21:	ROL3	d0,c1,c0		; shift carry into result c
000356 1ac6                      	sub	d0,b0			; subtract b from remainder
000357 f408                      	brcc	PC+2		
000358 0ec6                      	add	d0,b0			; restore if remainder became negative
000359 950a
00035a f7c1                      	DJNZ	w,_d21			; Decrement and Jump if bit-count Not Zero
00035b 1c88
00035c 1c99                      	ROL2	c1,c0			; last shift (carry into result c)
00035d 9490
00035e 9480                      	COM2	c1,c0			; complement result
00035f 9508                      	ret
                                 
000360 2e82
000361 2e93                      div22:	MOV2	c1,c0, a1,a0		; c will contain the result
000362 18dd
000363 24cc                      	CLR2	d1,d0			; d will contain the remainder
000364 e100                      	ldi	w,16			; load bit counter
000365 1c88
000366 1c99
000367 1ccc
000368 1cdd                      _d22:	ROL4	d1,d0,c1,c0		; shift carry into result c
000369 1ac6
00036a 0ad7                      	SUB2	d1,d0, b1,b0		; subtract b from remainder
00036b f410                      	brcc	PC+3	
00036c 0ec6
00036d 1ed7                      	ADD2	d1,d0, b1,b0		; restore if remainder became negative
00036e 950a
00036f f7a9                      	DJNZ	w,_d22			; Decrement and Jump if bit-count Not Zero
000370 1c88
000371 1c99                      	ROL2	c1,c0			; last shift (carry into result c)
000372 9490
000373 9480                      	COM2	c1,c0			; complement result
000374 9508                      	ret
                                 
000375 2e82
000376 2e93
000377 2ea4                      div31:	MOV3	c2,c1,c0, a2,a1,a0	; c will contain the result
000378 24cc                      	clr	d0			; d will contain the remainder
000379 e108                      	ldi	w,24			; load bit counter
00037a 1c88
00037b 1c99
00037c 1caa
00037d 1ccc                      _d31:	ROL4	d0,c2,c1,c0		; shift carry into result c
00037e 1ac6                      	sub	d0, b0			; subtract b from remainder
00037f f408                      	brcc	PC+2	
000380 0ec6                      	add	d0, b0			; restore if remainder became negative
000381 950a
000382 f7b9                      	DJNZ	w,_d31			; Decrement and Jump if bit-count Not Zero
000383 1c88
000384 1c99
000385 1caa                      	ROL3	c2,c1,c0		; last shift (carry into result c)
000386 94a0
000387 9490
000388 9480                      	COM3	c2,c1,c0		; complement result
000389 9508                      	ret
                                 
00038a 2e82
00038b 2e93
00038c 2ea4                      div32:	MOV3	c2,c1,c0, a2,a1,a0	; c will contain the result
00038d 18dd
00038e 24cc                      	CLR2	d1,d0			; d will contain the remainder
00038f e108                      	ldi	w,24			; load bit counter
000390 1c88
000391 1c99
000392 1caa
000393 1ccc
000394 1cdd                      _d32:	ROL5	d1,d0,c2,c1,c0		; shift carry into result c
000395 1ac6
000396 0ad7                      	SUB2	d1,d0, b1,b0		; subtract b from remainder
000397 f410                      	brcc	PC+3	
000398 0ec6
000399 1ed7                      	ADD2	d1,d0, b1,b0		; restore if remainder became negative
00039a 950a
00039b f7a1                      	DJNZ	w,_d32			; Decrement and Jump if bit-count Not Zero
00039c 1c88
00039d 1c99
00039e 1caa                      	ROL3	c2,c1,c0		; last shift (carry into result c)
00039f 94a0
0003a0 9490
0003a1 9480                      	COM3	c2,c1,c0		; complement result
0003a2 9508                      	ret
                                 	
0003a3 2e82
0003a4 2e93
0003a5 2ea4                      div33:	MOV3	c2,c1,c0, a2,a1,a0	; c will contain the result
0003a6 18ee
0003a7 24dd
0003a8 24cc                      	CLR3	d2,d1,d0		; d will contain the remainder
0003a9 e108                      	ldi	w,24			; load bit counter
0003aa 1c88
0003ab 1c99
0003ac 1caa
0003ad 1ccc
0003ae 1cdd
0003af 1cee                      _d33:	ROL6	d2,d1,d0,c2,c1,c0	; shift carry into result c
0003b0 1ac6
0003b1 0ad7
0003b2 0ae8                      	SUB3	d2,d1,d0, b2,b1,b0	; subtract b from remainder
0003b3 f418                      	brcc	PC+4	
0003b4 0ec6
0003b5 1ed7
0003b6 1ee8                      	ADD3	d2,d1,d0, b2,b1,b0	; restore if remainder became negative
0003b7 950a
0003b8 f789                      	DJNZ	w,_d33			; Decrement and Jump if bit-count Not Zero
0003b9 1c88
0003ba 1c99
0003bb 1caa                      	ROL3	c2,c1,c0		; last shift (carry into result c)
0003bc 94a0
0003bd 9490
0003be 9480                      	COM3	c2,c1,c0		; complement result
0003bf 9508                      	ret
                                 
0003c0 2e82
0003c1 2e93
0003c2 2ea4
0003c3 2eb5                      div41:	MOV4	c3,c2,c1,c0, a3,a2,a1,a0; c will contain the result
0003c4 24cc                      	clr	d0			; d will contain the remainder
0003c5 e200                      	ldi	w,32			; load bit counter
0003c6 1c88
0003c7 1c99
0003c8 1caa
0003c9 1cbb
0003ca 1ccc                      _d41:	ROL5	d0,c3,c2,c1,c0		; shift carry into result c
0003cb 1ac6                      	sub	d0, b0			; subtract b from remainder
0003cc f408                      	brcc	PC+2	
0003cd 0ec6                      	add	d0, b0			; restore if remainder became negative
0003ce 950a
0003cf f7b1                      	DJNZ	w,_d41			; Decrement and Jump if bit-count Not Zero
0003d0 1c88
0003d1 1c99
0003d2 1caa
0003d3 1cbb                      	ROL4	c3,c2,c1,c0		; last shift (carry into result c)
0003d4 94b0
0003d5 94a0
0003d6 9490
0003d7 9480                      	COM4	c3,c2,c1,c0		; complement result
0003d8 9508                      	ret
                                 
0003d9 2e82
0003da 2e93
0003db 2ea4
0003dc 2eb5                      div42:	MOV4	c3,c2,c1,c0, a3,a2,a1,a0; c will contain the result
0003dd 18dd
0003de 24cc                      	CLR2	d1,d0			; d will contain the remainder
0003df e200                      	ldi	w,32			; load bit counter
0003e0 1c88
0003e1 1c99
0003e2 1caa
0003e3 1cbb
0003e4 1ccc
0003e5 1cdd                      _d42:	ROL6	d1,d0,c3,c2,c1,c0	; shift carry into result c
0003e6 1ac6
0003e7 0ad7                      	SUB2	d1,d0, b1,b0		; subtract b from remainder
0003e8 f410                      	brcc	PC+3	
0003e9 0ec6
0003ea 1ed7                      	ADD2	d1,d0, b1,b0		; restore if remainder became negative
0003eb 950a
0003ec f799                      	DJNZ	w,_d42			; Decrement and Jump if bit-count Not Zero
0003ed 1c88
0003ee 1c99
0003ef 1caa
0003f0 1cbb                      	ROL4	c3,c2,c1,c0		; last shift (carry into result c)
0003f1 94b0
0003f2 94a0
0003f3 9490
0003f4 9480                      	COM4	c3,c2,c1,c0		; complement result
0003f5 9508                      	ret
                                 
0003f6 2e82
0003f7 2e93
0003f8 2ea4
0003f9 2eb5                      div43:	MOV4	c3,c2,c1,c0, a3,a2,a1,a0; c will contain the result
0003fa 18ee
0003fb 24dd
0003fc 24cc                      	CLR3	d2,d1,d0		; d will contain the remainder
0003fd e200                      	ldi	w,32			; load bit counter
0003fe 1c88
0003ff 1c99
000400 1caa
000401 1cbb
000402 1ccc
000403 1cdd
000404 1cee                      _d43:	ROL7	d2,d1,d0,c3,c2,c1,c0	; shift carry into result c
000405 1ac6
000406 0ad7
000407 0ae8                      	SUB3	d2,d1,d0, b2,b1,b0	; subtract b from remainder
000408 f418                      	brcc	PC+4	
000409 0ec6
00040a 1ed7
00040b 1ee8                      	ADD3	d2,d1,d0, b2,b1,b0	; restore if remainder became negative
00040c 950a
00040d f781                      	DJNZ	w,_d43			; Decrement and Jump if bit-count Not Zero
00040e 1c88
00040f 1c99
000410 1caa
000411 1cbb                      	ROL4	c3,c2,c1,c0		; last shift (carry into result c)
000412 94b0
000413 94a0
000414 9490
000415 9480                      	COM4	c3,c2,c1,c0		; complement result
000416 9508                      	ret
                                 
000417 2e82
000418 2e93
000419 2ea4
00041a 2eb5                      div44:	MOV4	c3,c2,c1,c0, a3,a2,a1,a0; c will contain the result
00041b 18ff
00041c 24ee
00041d 24dd
00041e 24cc                      	CLR4	d3,d2,d1,d0		; d will contain the remainder
00041f e200                      	ldi	w,32			; load bit counter
000420 1c88
000421 1c99
000422 1caa
000423 1cbb
000424 1ccc
000425 1cdd
000426 1cee
000427 1cff                      _d44:	ROL8	d3,d2,d1,d0,c3,c2,c1,c0	; shift carry into result c
000428 1ac6
000429 0ad7
00042a 0ae8
00042b 0af9                      	SUB4	d3,d2,d1,d0, b3,b2,b1,b0; subtract b from remainder
00042c f420                      	brcc	PC+5	
00042d 0ec6
00042e 1ed7
00042f 1ee8
000430 1ef9                      	ADD4	d3,d2,d1,d0, b3,b2,b1,b0; restore if remainder became negative
000431 950a
000432 f769                      	DJNZ	w,_d44			; Decrement and Jump if bit-count Not Zero
000433 1c88
000434 1c99
000435 1caa
000436 1cbb                      	ROL4	c3,c2,c1,c0		; last shift (carry into result c)
000437 94b0
000438 94a0
000439 9490
00043a 9480                      	COM4	c3,c2,c1,c0		; complement result
00043b 9508                      	ret
                                 
                                 ; === signed division ===
00043c 923f                      div33s:	push	u
00043d 2e34                      	mov	u,a2
00043e 2638                      	eor	u,b2
00043f ff47                      	sbrs	a2,7
000440 c007                      	rjmp	d33a
000441 9540
000442 9530
000443 9520
000444 ef0f
000445 1b20
000446 0b30
000447 0b40                      	NEG3	a2,a1,a0
000448 ff87                      d33a:	sbrs	b2,7
000449 c007                      	rjmp	d33b
00044a 9580
00044b 9570
00044c 9560
00044d ef0f
00044e 1b60
00044f 0b70
000450 0b80                      	NEG3	b2,b1,b0
000451 df51                      d33b:	rcall	div33
000452 fe37                      	sbrs	u,7
000453 c007                      	rjmp	d33c
000454 94a0
000455 9490
000456 9480
000457 ef0f
000458 1a80
000459 0a90
00045a 0aa0                      	NEG3	c2,c1,c0
00045b 903f                      d33c:	pop	u
                                 .include "sound.asm"		; include sound routines
00045c 9508                      
                                 ; purpose library, sound generation
                                 
                                 sound:
                                 ; in	a0	period of oscillation (in 10us)
                                 ; 	b0	duration of sound (in 2.5ms)
                                 
00045d 2f76                      	mov	b1,b0		; duration high byte = b
00045e 2766                      	clr	b0		; duration  low byte = 0
00045f 2733                      	clr	a1		; period high byte = a
000460 2322                      	tst	a0
000461 f071                      	breq	sound_off	; if a0=0 then no sound	
                                 sound1:
000462 2f02                      	mov	w,a0		
000463 d012                      	rcall	wait9us		; 9us
000464 0000                      	nop			; 0.25us
000465 950a                      	dec	w		; 0.25us
000466 f7e1                      	brne	PC-3		; 0.50us	total = 10us
000467 9b1a
000468 c002
000469 981a
00046a c001
00046b 9a1a                      	INVP	PORTE,SPEAKER	; invert piezo output
00046c 1b62                      	sub	b0,a0		; decrement duration low  byte
00046d 0b73                      	sbc	b1,a1		; decrement duration high byte
00046e f798                      	brcc	sound1		; continue if duration>0
00046f 9508                      	ret
                                 
                                 sound_off:
000470 e021                      	ldi	a0,1
000471 d004                      	rcall	wait9us
000472 1b62                      	sub	b0,a0		; decrement duration low  byte
000473 0b73                      	sbc	b1,a1		; decrement duration high byte
000474 f7e0                      	brcc	PC-3		; continue if duration>0
000475 9508                      	ret
                                 
                                 ; === wait routines ===
                                 
000476 c000                      wait9us:rjmp	PC+1		; waiting 2 cycles
000477 c000                      	rjmp	PC+1		; waiting 2 cylces
000478 d000                      wait8us:rcall	wait4us		; recursive call with "falling through"
000479 d000                      wait4us:rcall	wait2us	
00047a 0000                      wait2us:nop
00047b 9508                      	ret		; rcall(4), nop(1), ret(3) = 8cycl. (=2us)
                                 
                                 ; === calculation of the musical scale ===
                                  
                                 ; period (10us)	= 100'000/freq(Hz)
                                 .equ	do	= 100000/517	; (517 Hz)
                                 .equ	dom	= do*944/1000	; do major
                                 .equ	re	= do*891/1000
                                 .equ	rem	= do*841/1000	; re major
                                 .equ	mi	= do*794/1000
                                 .equ	fa	= do*749/1000
                                 .equ	fam	= do*707/1000	; fa major
                                 .equ	so	= do*667/1000
                                 .equ	som	= do*630/1000	; so major
                                 .equ	la	= do*595/1000
                                 .equ	lam	= do*561/1000	; la major
                                 .equ	si	= do*530/1000
                                 
                                 .equ	do2	= do/2
                                 .equ	dom2	= dom/2
                                 .equ	re2	= re/2
                                 .equ	rem2	= rem/2
                                 .equ	mi2	= mi/2
                                 .equ	fa2	= fa/2
                                 .equ	fam2	= fam/2
                                 .equ	so2	= so/2
                                 .equ	som2	= som/2
                                 .equ	la2	= la/2
                                 .equ	lam2	= lam/2
                                 .equ	si2	= si/2
                                 
                                 .equ	do3	= do/4
                                 .equ	dom3	= dom/4
                                 .equ	re3	= re/4
                                 .equ	rem3	= rem/4
                                 .equ	mi3	= mi/4
                                 .equ	fa3	= fa/4
                                 .equ	fam3	= fam/4
                                 .equ	so3	= so/4
                                 .equ	som3	= som/4
                                 .equ	la3	= la/4
                                 .equ	lam3	= lam/4
                                 .equ	si3	= si/4	
                                 
                                 main:
00047c b61f                      	in _sreg,SREG
00047d 94f8                      	cli
00047e 2d2b                      	mov a0,c3
00047f 1b29                      	sub a0, b3 ; T<Tmin ?
                                 
000480 f43a                      	brpl t_min
                                 	
000481 2d2d                      	mov a0,d1
000482 1b29                      	sub a0, b3 ; T>Tmax ?
                                 
000483 f030                      	brcs t_sup
                                 
000484 be1f                      	out SREG,_sreg
000485 9478                      	sei 
                                 
000486 d064                      	rcall conversion
                                 
000487 cff4                      	rjmp main
                                 
                                 t_min:
000488 d003                      	rcall tmin
000489 cff2                      	rjmp main
                                 
                                 t_sup:
00048a d031                      	rcall tsup
00048b cff0                      	rjmp main
                                 
                                 ; ====TMIN====
                                 tmin:
00048c dc2a
00048d 2f29
00048e ea09
00048f 2e40
000490 e000
000491 2e50
000492 dc54
000493 3d54
000494 12c0
000495 2043
000496 000d
000497 2d2d
000498 2d6b
000499 ea09
00049a 2e40
00049b e000
00049c 2e50
00049d dc49
00049e 540a
00049f 696d
0004a0 3d6e
0004a1 16c0
0004a2 5420
0004a3 616d
0004a4 3d78
0004a5 12c0
0004a6 2020
0004a7 0020                      	AFFICHER b3,d1,c3
                                 
0004a8 ee68                      	ldi b0, 0b11101000
0004a9 e073                      	ldi b1, 0b00000011	;b=paramters for the motor
0004aa 981c
0004ab e209
0004ac 2e30
0004ad e609
0004ae 943a
0004af f7f1
0004b0 943a
0004b1 950a
0004b2 f7d9
0004b3 9a1c
0004b4 5061
0004b5 4070
0004b6 f7e9
0004b7 981c                      	MOTOR b1,b0			;Activate it when the motor is connected
                                 
0004b8 be1f                      	out SREG,_sreg
0004b9 9478                      	sei
0004ba cfc1                      	rjmp main			
                                 
0004bb 9508                      	ret
                                 
                                 ; ====TSUP====
                                 tsup:
0004bc dbfa
0004bd 2f29
0004be ea09
0004bf 2e40
0004c0 e000
0004c1 2e50
0004c2 dc24
0004c3 3d54
0004c4 12c0
0004c5 2043
0004c6 000d
0004c7 2d2d
0004c8 2d6b
0004c9 ea09
0004ca 2e40
0004cb e000
0004cc 2e50
0004cd dc19
0004ce 540a
0004cf 696d
0004d0 3d6e
0004d1 16c0
0004d2 5420
0004d3 616d
0004d4 3d78
0004d5 12c0
0004d6 2020
0004d7 0020                      	AFFICHER b3,d1,c3
                                 
0004d8 ed60                      	ldi b0, 0b11010000
0004d9 e077                      	ldi b1, 0b00000111	;b=paramters for the motor
0004da 981c
0004db e209
0004dc 2e30
0004dd e609
0004de 943a
0004df f7f1
0004e0 943a
0004e1 950a
0004e2 f7d9
0004e3 9a1c
0004e4 5061
0004e5 4070
0004e6 f7e9
0004e7 981c                      	MOTOR b1,b0			;Activate it when the motor is connected
                                 	;rcall alarm		;Activate it when the speaker is connected
                                 
0004e8 be1f                      	out SREG,_sreg
0004e9 9478                      	sei	
                                 
0004ea 9508                      	ret
                                 	
                                 ;====CONVERSION====
                                 conversion :
0004eb b61f                      	in _sreg,SREG
0004ec 94f8                      	cli
                                 
0004ed 2f69                      	mov b0, b3 ; b0 = Tact
0004ee 2d2b                      	mov a0, c3 ; a0 = Tmin
                                 
0004ef 1b62                      	sub b0, a0 ; b0 = Tact-Tmin
                                 
0004f0 2488                      	clr c0
0004f1 2499                      	clr c1
                                 	
0004f2 ee28                      	ldi a0, 0b11101000
0004f3 e033                      	ldi a1, 0b00000011
                                 	
0004f4 dd66                      	rcall mul21	;c = 1000*(Tact-Tmin)
                                 
0004f5 2d28                      	mov a0, c0
0004f6 2d39                      	mov a1, c1
                                 	
0004f7 2d6d                      	mov b0, d1 ; b0 = Tmax
0004f8 2d7b                      	mov b1, c3 ; b1 = Tmin
                                 
0004f9 1b67                      	sub b0, b1 ; b0 = Tmax - Tmin
                                 
0004fa de54                      	rcall div21 ; c = 1000*(Tact-Tmin)/(Tmax-Tmin)
                                 	
0004fb 2ce9                      	mov d2,c1
0004fc 2d88                      	mov b2,c0	
                                 
0004fd dbb9
0004fe 2f29
0004ff ea09
000500 2e40
000501 e000
000502 2e50
000503 dbe3
000504 3d54
000505 12c0
000506 2043
000507 000d
000508 2d2d
000509 2d6b
00050a ea09
00050b 2e40
00050c e000
00050d 2e50
00050e dbd8
00050f 540a
000510 696d
000511 3d6e
000512 16c0
000513 5420
000514 616d
000515 3d78
000516 12c0
000517 2020
000518 0020                      	AFFICHER b3,d1,c3
                                 	
000519 2f68                      	mov b0,b2
00051a 2d7e                      	mov b1,d2	
                                 
00051b 5168
00051c 4f7c                      	ADDI2	b1,b0,1000	; add an offset of 1000	
00051d 981c
00051e e209
00051f 2e30
000520 e609
000521 943a
000522 f7f1
000523 943a
000524 950a
000525 f7d9
000526 9a1c
000527 5061
000528 4070
000529 f7e9
00052a 981c                      	MOTOR b1,b0			;Activate it when the motor is connected
                                 
00052b be1f                      	out SREG,_sreg
00052c 9478                      	sei
                                 
00052d 9508                      	ret
                                 
                                 ; ====ALARM====
                                 alarm: 
00052e ef2a                      	ldi a0,250	;parameter for the routine sound
00052f e164                      	ldi b0,20	;parameter for the routine sound
000530 df2c                      	rcall sound
000531 9508                      	ret


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :   6 y  :   0 z  :   0 r0 :   7 r1 :  20 r2 :   0 r3 :  16 r4 :   7 
r5 :   7 r6 :   0 r7 :   0 r8 :  80 r9 :  78 r10:  65 r11:  65 r12:  75 
r13:  58 r14:  25 r15:  11 r16: 200 r17:   0 r18: 104 r19:  62 r20:  44 
r21:  25 r22:  65 r23:  61 r24:  25 r25:  34 r26:   4 r27:   4 r28:   0 
r29:   0 r30:  11 r31:   6 
Registers used: 27 out of 35 (77.1%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  30 add   :  25 adiw  :   5 and   :   0 
andi  :   7 asr   :   2 bclr  :   0 bld   :   9 brbc  :   0 brbs  :   0 
brcc  :  25 brcs  :   1 break :   0 breq  :  19 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   0 brmi  :   1 
brne  :  41 brpl  :   2 brsh  :   3 brtc  :   5 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :  13 call  :   0 cbi   :  13 cbr   :   0 
clc   :   1 clh   :   0 cli   :   2 cln   :   0 clr   :  50 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  47 cp    :   1 cpc   :   3 
cpi   :  10 cpse  :   0 dec   :  42 elpm  :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   1 ijmp  :   1 in    :  12 inc   :   4 
jmp   :   4 ld    :   6 ldd   :   0 ldi   : 124 lds   :   3 lpm   :  12 
lsl   :   1 lsr   :  13 mov   : 115 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :   8 or    :   0 ori   :   2 out   :  22 
pop   :  26 push  :  25 rcall :  74 ret   :  53 reti  :   9 rjmp  :  55 
rol   :  90 ror   :  77 sbc   :  33 sbci  :   4 sbi   :   8 sbic  :   0 
sbis  :   1 sbiw  :   0 sbr   :   1 sbrc  :  13 sbrs  :   9 sec   :   0 
seh   :   0 sei   :   5 sen   :   0 ser   :   0 ses   :   0 set   :   1 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :   4 sub   :  50 subi  :   7 swap  :   4 tst   :   9 wdr   :   0 

Instructions used: 64 out of 114 (56.1%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000a64   2500     84   2584  131072   2.0%
[.dseg] 0x000100 0x000100      0      0      0    4096   0.0%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 0 warnings
